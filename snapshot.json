{
  "stats": {
    "total_files": 14,
    "total_classes": 52,
    "total_interfaces": 6,
    "total_enums": 12,
    "total_typedefs": 8,
    "total_functions": 72,
    "entities_count": 19,
    "repositories_count": 0,
    "services_count": 0,
    "value_objects_count": 14
  },
  "classes": {
    "EntityCreationConfig": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "methods": [],
      "properties": [
        {
          "name": "name",
          "type": "String",
          "doc": "User-provided name for the entity"
        },
        {
          "name": "user",
          "type": "AuthUser",
          "doc": "User creating the entity"
        },
        {
          "name": "data",
          "type": "T",
          "doc": "Type-specific payload data"
        }
      ]
    },
    "EntityCloningConfig": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "methods": [],
      "properties": [
        {
          "name": "source",
          "type": "BaseEntityModel<T>",
          "doc": "Source entity to clone"
        },
        {
          "name": "user",
          "type": "AuthUser",
          "doc": "User performing the cloning operation"
        }
      ]
    },
    "EntityCreationBuilder": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "methods": [
        {
          "name": "withName",
          "params": "String name",
          "doc": "Sets the name for the entity"
        },
        {
          "name": "withUser",
          "params": "AuthUser user",
          "doc": "Sets the user creating the entity"
        },
        {
          "name": "withData",
          "params": "T data",
          "doc": "Sets the type-specific payload data"
        },
        {
          "name": "withDescription",
          "params": "String description",
          "doc": "Sets the description for the entity"
        },
        {
          "name": "withParentPath",
          "params": "String parentPath",
          "doc": "Sets the parent path in the entity hierarchy"
        },
        {
          "name": "withParentId",
          "params": "EntityId parentId",
          "doc": "Sets the direct parent entity ID"
        },
        {
          "name": "withAncestors",
          "params": "List<EntityId> ancestors",
          "doc": "Sets the list of ancestor entity IDs"
        },
        {
          "name": "withMeta",
          "params": "Map<String, Object> meta",
          "doc": "Sets custom metadata key-value pairs"
        },
        {
          "name": "withTags",
          "params": "List<String> tags",
          "doc": "Sets searchable tags"
        },
        {
          "name": "withLabels",
          "params": "Map<String, String> labels",
          "doc": "Sets categorization labels"
        },
        {
          "name": "withPriority",
          "params": "EntityPriority priority",
          "doc": "Sets the entity importance level"
        },
        {
          "name": "withStage",
          "params": "EntityStage stage",
          "doc": "Sets the workflow stage"
        },
        {
          "name": "withExpiryDate",
          "params": "DateTime expiryDate",
          "doc": "Sets the expiry date for the entity"
        },
        {
          "name": "isPublic",
          "params": "bool isPublic",
          "doc": "Sets whether the entity is publicly accessible"
        },
        {
          "name": "build",
          "params": "",
          "doc": ""
        },
        {
          "name": "if",
          "params": "_name == null",
          "doc": ""
        },
        {
          "name": "ArgumentError",
          "params": "'Entity name is required');\n    }\n    if (_user == null",
          "doc": ""
        },
        {
          "name": "ArgumentError",
          "params": "'User is required');\n    }\n    if (_data == null",
          "doc": ""
        }
      ],
      "properties": [
        {
          "name": "this",
          "type": "return",
          "doc": "Sets the name for the entity\n  EntityCreationBuilder<T> withName(String name) {\n    _name = name;"
        },
        {
          "name": "this",
          "type": "return",
          "doc": "Sets the user creating the entity\n  EntityCreationBuilder<T> withUser(AuthUser user) {\n    _user = user;"
        },
        {
          "name": "this",
          "type": "return",
          "doc": "Sets the type-specific payload data\n  EntityCreationBuilder<T> withData(T data) {\n    _data = data;"
        },
        {
          "name": "this",
          "type": "return",
          "doc": "Sets the description for the entity\n  EntityCreationBuilder<T> withDescription(String description) {\n    _description = description;"
        },
        {
          "name": "this",
          "type": "return",
          "doc": "Sets the parent path in the entity hierarchy\n  EntityCreationBuilder<T> withParentPath(String parentPath) {\n    _parentPath = parentPath;"
        },
        {
          "name": "this",
          "type": "return",
          "doc": "Sets the direct parent entity ID\n  EntityCreationBuilder<T> withParentId(EntityId parentId) {\n    _parentId = parentId;"
        },
        {
          "name": "this",
          "type": "return",
          "doc": "Sets the list of ancestor entity IDs\n  EntityCreationBuilder<T> withAncestors(List<EntityId> ancestors) {\n    _ancestors = ancestors;"
        },
        {
          "name": "this",
          "type": "return",
          "doc": "Sets custom metadata key-value pairs\n  EntityCreationBuilder<T> withMeta(Map<String, Object> meta) {\n    _meta = meta;"
        },
        {
          "name": "this",
          "type": "return",
          "doc": "Sets searchable tags\n  EntityCreationBuilder<T> withTags(List<String> tags) {\n    _tags = tags;"
        },
        {
          "name": "this",
          "type": "return",
          "doc": "Sets categorization labels\n  EntityCreationBuilder<T> withLabels(Map<String, String> labels) {\n    _labels = labels;"
        },
        {
          "name": "this",
          "type": "return",
          "doc": "Sets the entity importance level\n  EntityCreationBuilder<T> withPriority(EntityPriority priority) {\n    _priority = priority;"
        },
        {
          "name": "this",
          "type": "return",
          "doc": "Sets the workflow stage\n  EntityCreationBuilder<T> withStage(EntityStage stage) {\n    _stage = stage;"
        },
        {
          "name": "this",
          "type": "return",
          "doc": "Sets the expiry date for the entity\n  EntityCreationBuilder<T> withExpiryDate(DateTime expiryDate) {\n    _expiryDate = expiryDate;"
        },
        {
          "name": "this",
          "type": "return",
          "doc": "Sets whether the entity is publicly accessible\n  EntityCreationBuilder<T> isPublic(bool isPublic) {\n    _isPublic = isPublic;"
        },
        {
          "name": "config",
          "type": "final",
          "doc": ""
        }
      ]
    },
    "EntityCloningBuilder": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "methods": [
        {
          "name": "fromSource",
          "params": "BaseEntityModel<T> source",
          "doc": "Sets the source entity to clone"
        },
        {
          "name": "withUser",
          "params": "AuthUser user",
          "doc": "Sets the user performing the clone operation"
        },
        {
          "name": "withName",
          "params": "String newName",
          "doc": "Sets the name for the cloned entity"
        },
        {
          "name": "withPath",
          "params": "String newPath",
          "doc": "Sets the path for the cloned entity"
        },
        {
          "name": "withMeta",
          "params": "Map<String, Object> newMeta",
          "doc": "Sets custom metadata for the cloned entity"
        },
        {
          "name": "withLabels",
          "params": "Map<String, String> newLabels",
          "doc": "Sets labels for the cloned entity"
        },
        {
          "name": "withTags",
          "params": "List<String> newTags",
          "doc": "Sets tags for the cloned entity"
        },
        {
          "name": "build",
          "params": "",
          "doc": ""
        },
        {
          "name": "if",
          "params": "_source == null",
          "doc": ""
        },
        {
          "name": "ArgumentError",
          "params": "'Source entity is required');\n    }\n    if (_user == null",
          "doc": ""
        }
      ],
      "properties": [
        {
          "name": "this",
          "type": "return",
          "doc": "Sets the source entity to clone\n  EntityCloningBuilder<T> fromSource(BaseEntityModel<T> source) {\n    _source = source;"
        },
        {
          "name": "this",
          "type": "return",
          "doc": "Sets the user performing the clone operation\n  EntityCloningBuilder<T> withUser(AuthUser user) {\n    _user = user;"
        },
        {
          "name": "this",
          "type": "return",
          "doc": "Sets the name for the cloned entity\n  EntityCloningBuilder<T> withName(String newName) {\n    _newName = newName;"
        },
        {
          "name": "this",
          "type": "return",
          "doc": "Sets the path for the cloned entity\n  EntityCloningBuilder<T> withPath(String newPath) {\n    _newPath = newPath;"
        },
        {
          "name": "this",
          "type": "return",
          "doc": "Sets custom metadata for the cloned entity\n  EntityCloningBuilder<T> withMeta(Map<String, Object> newMeta) {\n    _newMeta = newMeta;"
        },
        {
          "name": "this",
          "type": "return",
          "doc": "Sets labels for the cloned entity\n  EntityCloningBuilder<T> withLabels(Map<String, String> newLabels) {\n    _newLabels = newLabels;"
        },
        {
          "name": "this",
          "type": "return",
          "doc": "Sets tags for the cloned entity\n  EntityCloningBuilder<T> withTags(List<String> newTags) {\n    _newTags = newTags;"
        },
        {
          "name": "config",
          "type": "final",
          "doc": ""
        }
      ]
    },
    "EntityFactory": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "methods": [
        {
          "name": "if",
          "params": "!_validTypes.contains(T)",
          "doc": "Valid entity types that can be created with this factory\n  static final _validTypes = <Type>{\n    OwnerData,\n    SiteData,\n    EquipmentData,\n    VendorData,\n    PersonnelData,\n  };\n\n  /// Creates a new entity from the provided configuration.\n  ///\n  /// For a more fluent API, consider using [EntityCreationBuilder] instead.\n  ///\n  /// Example with builder pattern:\n  /// ```dart\n  /// final entity = EntityCreationBuilder<SiteModel>()\n  ///   .withName('Site Name')\n  ///   .withUser(currentUser)\n  ///   .withData(siteData)\n  ///   // ... more properties ...\n  ///   .build();\n  /// ```\n  ///\n  /// @param config The configuration containing all entity parameters\n  /// @return A new entity with the specified configuration\n  /// @throws ArgumentError if an invalid type is provided\n  /// @throws PathValidationException if the provided path is invalid\n  /// @throws HierarchyValidationException if a circular reference is detected\n  static BaseEntityModel<T> create<T extends Object>(\n    EntityCreationConfig<T> config,\n  ) {"
        },
        {
          "name": "ArgumentError",
          "params": "'Invalid type: ${T.toString()}');\n    }\n\n    final now = DateTime.now();\n    final userAction = UserAction.fromAuthUser(config.user);\n    final id = EntityId(const Uuid().v4());\n\n    // Create core entity\n    final core = CoreEntity<T>(\n      id: id,\n      name: config.name,\n      description: config.description,\n      createdAt: now,\n      updatedAt: now,\n      owner: userAction,\n      creator: userAction,\n      modifier: userAction,\n      data: config.data,\n      meta: config.meta ?? {},\n    );\n\n    // Create entity with component structure\n    var entity = BaseEntityModel<T>(\n      core: core,\n      hierarchy: EntityHierarchy(\n        treePath: config.parentPath,\n        parentId: config.parentId,\n        ancestors: config.ancestors ?? [],\n        isHierarchyRoot: config.parentId == null,\n        isHierarchyLeaf: true,\n      ),\n      security: EntitySecurity(\n        modHistory: [userAction],\n        accessLog: [userAction],\n        isPublic: config.isPublic ?? EntityDefaults.isPublic,\n      ),\n      classification: EntityClassification(\n        tags: config.tags ?? [],\n        labels: config.labels ?? {},\n        priority: config.priority ?? EntityDefaults.priority,\n        stage: config.stage ?? EntityDefaults.stage,\n        expiryDate: config.expiryDate,\n      ),\n      versioning: const EntityVersioning(),\n    );\n\n    // Use extension methods for validation and path processing\n    if (!entity.isValidPath(entity.hierarchy.treePath)",
          "doc": ""
        },
        {
          "name": "PathValidationException",
          "params": "message: 'Invalid path format',\n        path: entity.hierarchy.treePath,\n      );\n    }\n\n    if (entity.hasCircularReference()",
          "doc": ""
        },
        {
          "name": "HierarchyValidationException",
          "params": "message: 'Circular reference detected',\n        field: 'hierarchy',\n        depth: entity.hierarchy.ancestors.length,\n        path: entity.hierarchy.ancestors.map((a",
          "doc": ""
        }
      ],
      "properties": [
        {
          "name": "_validTypes",
          "type": "final",
          "doc": "Valid entity types that can be created with this factory"
        },
        {
          "name": "now",
          "type": "final",
          "doc": "Creates a new entity from the provided configuration.\n  ///\n  /// For a more fluent API, consider using [EntityCreationBuilder] instead.\n  ///\n  /// Example with builder pattern:\n  /// ```dart\n  /// final entity = EntityCreationBuilder<SiteModel>()\n  ///   .withName('Site Name')\n  ///   .withUser(currentUser)\n  ///   .withData(siteData)\n  ///   // ... more properties ...\n  ///   .build();\n  /// ```\n  ///\n  /// @param config The configuration containing all entity parameters\n  /// @return A new entity with the specified configuration\n  /// @throws ArgumentError if an invalid type is provided\n  /// @throws PathValidationException if the provided path is invalid\n  /// @throws HierarchyValidationException if a circular reference is detected\n  static BaseEntityModel<T> create<T extends Object>(\n    EntityCreationConfig<T> config,\n  ) {\n    if (!_validTypes.contains(T)) {\n      throw ArgumentError('Invalid type: ${T.toString()}');\n    }"
        },
        {
          "name": "userAction",
          "type": "final",
          "doc": ""
        },
        {
          "name": "id",
          "type": "final",
          "doc": ""
        },
        {
          "name": "core",
          "type": "final",
          "doc": ""
        },
        {
          "name": "entity",
          "type": "var",
          "doc": ""
        },
        {
          "name": "searchIndex",
          "type": "final",
          "doc": ""
        },
        {
          "name": "now",
          "type": "final",
          "doc": "Creates a clone of an existing entity with optional modifications.\n  ///\n  /// For a more fluent API, consider using [EntityCloningBuilder] instead.\n  ///\n  /// Example with builder pattern:\n  /// ```dart\n  /// final clonedEntity = EntityCloningBuilder<SiteModel>()\n  ///   .fromSource(existingEntity)\n  ///   .withUser(currentUser)\n  ///   .withName('New Name')\n  ///   .build();\n  /// ```\n  ///\n  /// @param config The configuration for cloning, including source entity and overrides\n  /// @return A new entity based on the source with applied modifications\n  static BaseEntityModel<T> clone<T extends Object>(\n    EntityCloningConfig<T> config,\n  ) {"
        },
        {
          "name": "userAction",
          "type": "final",
          "doc": ""
        },
        {
          "name": "id",
          "type": "final",
          "doc": ""
        },
        {
          "name": "source",
          "type": "final",
          "doc": ""
        },
        {
          "name": "core",
          "type": "final",
          "doc": ""
        },
        {
          "name": "entity",
          "type": "var",
          "doc": ""
        },
        {
          "name": "searchIndex",
          "type": "final",
          "doc": ""
        }
      ]
    },
    "OwnerData": {
      "file": "lib/src/domain/entities/entity_types.dart",
      "methods": [
        {
          "name": "OwnerData",
          "params": "{\n    // Core info\n    required ContactInfo contact,\n    @Default([]) List<EntityId> siteIds,\n\n    // Metadata\n    @Default({}) Map<String, Object> meta,\n    Map<String, Object>? customData,\n  }) = _OwnerData;\n\n  factory OwnerData.fromJson(Map<String, Object> json",
          "doc": "Entity owner data model representing an organization or individual\n  ///\n  /// Stores contact information and site references"
        },
        {
          "name": "applyEvent",
          "params": "DomainEventModel event",
          "doc": "Whether this owner has associated sites\n  bool get hasSites => siteIds.isNotEmpty;\n\n  /// Whether owner has multiple sites\n  bool get hasMultipleSites => siteIds.length > 1;\n\n  /// Whether valid contact information exists\n  bool get hasValidContact => contact.email != null || contact.phone != null;\n\n  /// Human-readable name for display\n  String get displayName => contact.displayName;\n\n  /// Applies domain event and returns updated state\n  ///\n  /// Processes event data to create new entity state without mutation"
        },
        {
          "name": "switch",
          "params": "event.eventType",
          "doc": ""
        }
      ],
      "properties": []
    },
    "SiteData": {
      "file": "lib/src/domain/entities/entity_types.dart",
      "methods": [
        {
          "name": "SiteData",
          "params": "{\n    // Core info\n    required String name,\n    required EntityId ownerId,\n\n    // Location\n    String? address,\n    double? latitude,\n    double? longitude,\n\n    // Equipment\n    @Default([]) List<EntityId> equipmentIds,\n\n    // Details\n    @Default({}) Map<String, Object> siteInfo,\n\n    // Metadata\n    Map<String, Object>? customData,\n    @Default({}) Map<String, Object> meta,\n    @Default({}) Map<String, String> contactInfo,\n  }) = _SiteData;\n\n  factory SiteData.fromJson(Map<String, Object> json",
          "doc": "Data model for physical location or site\n  ///\n  /// [name] - Name of the site\n  /// [ownerId] - Reference to the owner of the site\n  /// [address] - Optional physical address\n  /// [equipmentIds] - Equipment installed at this site"
        },
        {
          "name": "applyEvent",
          "params": "DomainEventModel event",
          "doc": "Whether site has valid geolocation coordinates\n  bool get hasLocation => latitude != null && longitude != null;\n\n  /// Formatted location coordinates string\n  String get locationCoords => hasLocation ? '$latitude,$longitude' : '';\n\n  /// Whether site has associated equipment\n  bool get hasEquipment => equipmentIds.isNotEmpty;\n\n  /// Handles domain events by generating new state\n  ///\n  /// Returns updated SiteData reflecting the applied event"
        },
        {
          "name": "switch",
          "params": "event.eventType",
          "doc": ""
        }
      ],
      "properties": []
    },
    "EquipmentData": {
      "file": "lib/src/domain/entities/entity_types.dart",
      "methods": [
        {
          "name": "EquipmentData",
          "params": "{\n    // Core info\n    required String name,\n    required EntityId siteId,\n    required EquipmentType type,\n\n    // Technical info\n    String? serialNum,\n    String? modelId,\n    String? manufacturer,\n\n    // Specs\n    @Default({}) Map<String, Object> specs,\n\n    // Dates\n    DateTime? installDate,\n    DateTime? lastMaintDate,\n\n    // Hierarchy\n    EntityId? parentId,\n    @Default([]) List<EntityId> childIds,\n\n    // Metadata\n    Map<String, Object>? customData,\n    @Default({}) Map<String, Object> meta,\n    @Default({}) Map<String, String> maintContacts,\n  }) = _EquipmentData;\n\n  factory EquipmentData.fromJson(Map<String, Object> json",
          "doc": "Data model for physical equipment or machinery\n  ///\n  /// [name] - Name of the equipment\n  /// [siteId] - Site where equipment is installed\n  /// [type] - Equipment type classification\n  /// [serialNum] - Optional manufacturer serial number\n  /// [parentId] - Optional parent equipment for hierarchical structures\n  /// [childIds] - Sub-components of this equipment"
        },
        {
          "name": "applyEvent",
          "params": "DomainEventModel event",
          "doc": "Whether equipment requires maintenance (over 180 days since last)\n  bool get needsMaintenance =>\n      lastMaintDate?.isBefore(\n        DateTime.now().subtract(const Duration(days: 180)),\n      ) ??\n      true;\n\n  /// Whether equipment was installed in the last 30 days\n  bool get isNewInstall =>\n      installDate?.isAfter(DateTime.now().subtract(const Duration(days: 30))) ??\n      false;\n\n  /// Whether equipment has child components\n  bool get hasChildren => childIds.isNotEmpty;\n\n  /// Whether equipment is a child/sub-component\n  bool get isChild => parentId != null;\n\n  /// Whether equipment is a root component (not a child)\n  bool get isRoot => parentId == null;\n\n  /// Whether equipment has sub-components\n  bool get hasSubComponents => childIds.isNotEmpty;\n\n  /// Handles domain events by generating new state\n  ///\n  /// Returns updated EquipmentData reflecting the applied event"
        },
        {
          "name": "switch",
          "params": "event.eventType",
          "doc": ""
        }
      ],
      "properties": []
    },
    "VendorData": {
      "file": "lib/src/domain/entities/entity_types.dart",
      "methods": [
        {
          "name": "VendorData",
          "params": "{\n    // Core info\n    required ContactInfo contact,\n    @Default([]) List<EntityId> staffIds,\n    @Default([]) List<String> services,\n\n    // Metadata\n    @Default({}) Map<String, Object> meta,\n    Map<String, Object>? customData,\n    @Default({}) Map<String, Object> certifications,\n  }) = _VendorData;\n\n  factory VendorData.fromJson(Map<String, Object> json",
          "doc": "Data model for external service providers or vendors\n  ///\n  /// [contact] - Main contact information for the vendor\n  /// [staffIds] - Personnel working for this vendor\n  /// [services] - Types of services offered\n  /// [certifications] - Professional certifications held"
        },
        {
          "name": "applyEvent",
          "params": "DomainEventModel event",
          "doc": "Whether vendor has associated staff members\n  bool get hasStaff => staffIds.isNotEmpty;\n\n  /// Whether vendor provides services\n  bool get hasServices => services.isNotEmpty;\n\n  /// Human-readable name for display\n  String get displayName => contact.displayName;\n\n  /// Whether valid contact information exists\n  bool get hasValidContact => contact.email != null || contact.phone != null;\n\n  /// Handles domain events by generating new state\n  ///\n  /// Returns updated VendorData reflecting the applied event"
        },
        {
          "name": "switch",
          "params": "event.eventType",
          "doc": ""
        }
      ],
      "properties": []
    },
    "PersonnelData": {
      "file": "lib/src/domain/entities/entity_types.dart",
      "methods": [
        {
          "name": "PersonnelData",
          "params": "{\n    // Core info\n    required String name,\n    required EntityId vendorId,\n    required int skillLevel,\n\n    // Professional info\n    String? role,\n    @Default([]) List<String> certs,\n    @Default([]) List<String> specs,\n\n    // Contact info\n    String? phone,\n    String? email,\n\n    // Metadata\n    Map<String, Object>? customData,\n    @Default({}) Map<String, Object> meta,\n    @Default({}) Map<String, Object> schedule,\n    @Default({}) Map<String, DateTime> certDates,\n  }) = _PersonnelData;\n\n  factory PersonnelData.fromJson(Map<String, Object> json",
          "doc": "Data model for individuals providing services\n  ///\n  /// [name] - Name of the person\n  /// [vendorId] - Associated vendor/employer\n  /// [skillLevel] - Numeric rating of skill (1-10)\n  /// [certs] - Professional certifications\n  /// [specs] - Areas of specialization\n  /// [certDates] - Expiration dates for certifications"
        },
        {
          "name": "applyEvent",
          "params": "DomainEventModel event",
          "doc": "Whether person holds certifications\n  bool get isCertified => certs.isNotEmpty;\n\n  /// Whether person has specialized skills\n  bool get isSpecialized => specs.isNotEmpty;\n\n  /// Whether valid contact information exists\n  bool get hasValidContact => email != null || phone != null;\n\n  /// Primary certification, if any\n  String? get primaryCert => certs.isNotEmpty ? certs.first : null;\n\n  /// Whether certifications are valid and have dates\n  bool get hasValidCerts => certs.isNotEmpty && certDates.isNotEmpty;\n\n  /// Gets the expiration date for a specific certification\n  DateTime? getCertExpiry(String cert) => certDates[cert];\n\n  /// Handles domain events by generating new state\n  ///\n  /// Returns updated PersonnelData reflecting the applied event"
        },
        {
          "name": "switch",
          "params": "event.eventType",
          "doc": ""
        }
      ],
      "properties": []
    },
    "EntityLimits": {
      "file": "lib/src/domain/entities/base_entity.dart",
      "methods": [],
      "properties": [
        {
          "name": "pathMaxLength",
          "type": "int",
          "doc": "Maximum length of a path in characters"
        },
        {
          "name": "pathMaxSegment",
          "type": "int",
          "doc": "Maximum length of a path segment in characters"
        },
        {
          "name": "hierarchyDepthMax",
          "type": "int",
          "doc": "Maximum allowed depth in entity hierarchy"
        },
        {
          "name": "historyMax",
          "type": "int",
          "doc": "Maximum number of history entries to retain"
        },
        {
          "name": "historyDefault",
          "type": "int",
          "doc": "Default number of history entries to retain"
        }
      ]
    },
    "EntityHierarchy": {
      "file": "lib/src/domain/entities/base_entity.dart",
      "methods": [
        {
          "name": "EntityHierarchy",
          "params": "{\n    /// Full path in the entity tree\n    ///\n    /// Format: '/parent_id/grandparent_id/entity_id'\n    /// Paths use forward slashes as separators and start with a leading slash\n    /// Path segments are entity IDs in reverse ancestry order\n    String? treePath,\n\n    /// Depth level in the hierarchy (0 = root)\n    @Default(0) int treeDepth,\n\n    /// List of ancestor entity IDs in order from root to parent\n    @Default(<EntityId>[]) List<EntityId> ancestors,\n\n    /// Direct parent entity ID\n    EntityId? parentId,\n\n    /// List of direct child entity IDs\n    @Default(<EntityId>[]) List<EntityId> childIds,\n\n    /// Indicates if this entity is a root node in a hierarchy\n    @Default(true) bool isHierarchyRoot,\n\n    /// Indicates if this entity is a leaf node (has no children)\n    @Default(true) bool isHierarchyLeaf,\n\n    /// Additional hierarchy-related metadata\n    @Default({}) Map<String, Object> hierarchyMeta,\n  }) = _EntityHierarchy;\n\n  /// Creates a new root EntityHierarchy instance\n  factory EntityHierarchy.root(String entityId",
          "doc": "Creates a new EntityHierarchy instance"
        }
      ],
      "properties": [
        {
          "name": "now",
          "type": "final",
          "doc": "Creates a new EntityHierarchy instance\n  const factory EntityHierarchy({\n    /// Full path in the entity tree\n    ///\n    /// Format: '/parent_id/grandparent_id/entity_id'\n    /// Paths use forward slashes as separators and start with a leading slash\n    /// Path segments are entity IDs in reverse ancestry order\n    String? treePath,\n\n    /// Depth level in the hierarchy (0 = root)\n    @Default(0) int treeDepth,\n\n    /// List of ancestor entity IDs in order from root to parent\n    @Default(<EntityId>[]) List<EntityId> ancestors,\n\n    /// Direct parent entity ID\n    EntityId? parentId,\n\n    /// List of direct child entity IDs\n    @Default(<EntityId>[]) List<EntityId> childIds,\n\n    /// Indicates if this entity is a root node in a hierarchy\n    @Default(true) bool isHierarchyRoot,\n\n    /// Indicates if this entity is a leaf node (has no children)\n    @Default(true) bool isHierarchyLeaf,\n\n    /// Additional hierarchy-related metadata\n    @Default({}) Map<String, Object> hierarchyMeta,\n  }) = _EntityHierarchy;\n\n  /// Creates a new root EntityHierarchy instance\n  factory EntityHierarchy.root(String entityId) {"
        }
      ]
    },
    "EntitySecurity": {
      "file": "lib/src/domain/entities/base_entity.dart",
      "methods": [],
      "properties": []
    },
    "EntityClassification": {
      "file": "lib/src/domain/entities/base_entity.dart",
      "methods": [],
      "properties": []
    },
    "EntityVersioning": {
      "file": "lib/src/domain/entities/base_entity.dart",
      "methods": [],
      "properties": []
    },
    "BaseEntityModel": {
      "file": "lib/src/domain/entities/base_entity.dart",
      "methods": [
        {
          "name": "BaseEntityModel",
          "params": "{\n    /// Core entity data containing essential properties\n    required CoreEntity<T> core,\n\n    /// Component for hierarchy and tree structure\n    required EntityHierarchy hierarchy,\n\n    /// Component for access control and security\n    required EntitySecurity security,\n\n    /// Component for organization and workflow\n    required EntityClassification classification,\n\n    /// Component for change tracking and history\n    required EntityVersioning versioning,\n\n    /// Optional extra data of type T\n    T? extraData,\n  }) = _BaseEntityModel<T>;\n\n  // Delegate core properties\n  /// Unique identifier of the entity\n  EntityId get id => core.id;\n\n  /// Human-readable name of the entity\n  String get name => core.name;\n\n  /// Optional description of the entity\n  String? get description => core.description;\n\n  /// When the entity was created\n  DateTime get createdAt => core.createdAt;\n\n  /// When the entity was last updated\n  DateTime get updatedAt => core.updatedAt;\n\n  /// Schema version of the entity\n  String get schemaVer => core.schemaVer;\n\n  /// Current status of the entity\n  EntityStatus get status => core.status;\n\n  /// Custom metadata for the entity\n  Map<String, Object> get meta => core.meta;\n\n  /// User who owns the entity\n  UserAction get owner => core.owner;\n\n  /// User who created the entity\n  UserAction get creator => core.creator;\n\n  /// User who last modified the entity\n  UserAction get modifier => core.modifier;\n\n  // Component-based property getters\n  /// Access to versioning component\n  EntityVersioning get version => versioning;\n\n  // Core helpers\n  /// String representation of the entity ID\n  String get uid => core.uid;\n\n  /// Type name of the entity data\n  String get type => core.type;\n\n  // Short accessors to reduce verbosity\n  /// Whether this entity is at the root of a hierarchy\n  bool get isRoot => hierarchy.isHierarchyRoot;\n\n  /// Whether this entity is a leaf node (has no children)\n  bool get isLeaf => hierarchy.isHierarchyLeaf;\n\n  /// Path to the parent entity, if any (just the parent ID)\n  String? get parentPath => hierarchy.parentId?.value;\n\n  /// Full path to the parent entity in the hierarchy (excluding this entity's ID)\n  /// Returns null if this entity is root or treePath is not set.\n  String? get parentFullPath {\n    final path = hierarchy.treePath;\n    if (path == null || !path.contains('/')) return null;\n    final segments = path.split('/').where((s",
          "doc": "Creates a new BaseEntityModel instance with its component parts\n  ///\n  /// [core] - Core entity properties and data\n  /// [hierarchy] - Tree structure and relationships\n  /// [security] - Access control and permissions\n  /// [classification] - Tags, categories and workflow information\n  /// [versioning] - Version control and history tracking\n  /// [extraData] - Optional additional typed data"
        },
        {
          "name": "if",
          "params": "segments.length <= 1) return null;\n    // Remove the last segment (this entity's ID)\n    return '/${segments.sublist(0, segments.length - 1).join('/')}';\n  }\n\n  /// Adds a child entity relationship, ensuring hierarchy consistency\n  ///\n  /// [childId] - The ID of the child entity to add\n  /// Returns an updated entity with the child added and leaf status updated\n  BaseEntityModel<T> _addChildEntity(EntityId childId",
          "doc": ""
        },
        {
          "name": "if",
          "params": "hierarchy.childIds.contains(childId)) return this;\n    return copyWith(hierarchy: hierarchy.addChild(childId));\n  }\n\n  /// Removes a child entity relationship, ensuring hierarchy consistency.\n  ///\n  /// [childId] - The ID of the child entity to remove.\n  /// Returns an updated entity with the child removed and leaf status updated.\n  BaseEntityModel<T> _removeChildEntity(EntityId childId",
          "doc": ""
        },
        {
          "name": "if",
          "params": "!hierarchy.childIds.contains(childId)) return this;\n    return copyWith(hierarchy: hierarchy.removeChild(childId));\n  }\n\n  /// Validates and corrects the hierarchy leaf status if needed\n  ///\n  /// This method ensures that the [isHierarchyLeaf] property correctly reflects\n  /// whether the entity has children or not.\n  ///\n  /// Returns an updated entity with corrected leaf status\n  BaseEntityModel<T> validateHierarchyLeafStatus(",
          "doc": ""
        },
        {
          "name": "copyWith",
          "params": "hierarchy: hierarchy.validateLeafStatus());\n  }\n\n  /// Creates a new entity with standard configuration or custom components\n  ///\n  /// [id] - Unique identifier for the entity\n  /// [name] - Display name for the entity\n  /// [owner] - User who owns the entity\n  /// [data] - Typed payload data\n  /// [config] - Optional configuration parameters\n  /// [hierarchy] - Optional custom hierarchy component\n  /// [security] - Optional custom security component\n  /// [classification] - Optional custom classification component\n  /// [versioning] - Optional custom versioning component\n  factory BaseEntityModel.create({\n    required EntityId id,\n    required String name,\n    required UserAction owner,\n    required T data,\n    EntityConfig? config,\n    EntityHierarchy? hierarchy,\n    EntitySecurity? security,\n    EntityClassification? classification,\n    EntityVersioning? versioning,\n  }",
          "doc": ""
        },
        {
          "name": "BaseEntityModel",
          "params": "core: CoreEntity(\n        id: id,\n        name: name,\n        createdAt: now,\n        updatedAt: now,\n        owner: owner,\n        creator: owner,\n        modifier: owner,\n        data: data,\n      ),\n      hierarchy:\n          hierarchy ??\n          EntityHierarchy(\n            treePath: id.value,\n            isHierarchyRoot: true,\n            isHierarchyLeaf: true,\n            hierarchyMeta: {\n              'created': now.toIso8601String(),\n              'pathType': 'root',\n            },\n          ),\n      security: security ?? const EntitySecurity(),\n      classification: classification ?? const EntityClassification(),\n      versioning: versioning ?? const EntityVersioning(),\n    );\n  }\n\n  /// Adds a child to a parent and updates both entities' hierarchy fields for consistency.\n  ///\n  /// Returns a Dart 3 record (updatedParent, updatedChild).\n  static (BaseEntityModel<T>, BaseEntityModel<T>) addChildAndUpdateChild<\n    T extends Object\n  >(BaseEntityModel<T> parent, BaseEntityModel<T> child",
          "doc": ""
        },
        {
          "name": "return",
          "params": "updatedParent, updatedChild);\n  }\n\n  /// Removes a child from a parent and updates both entities' hierarchy fields for consistency.\n  ///\n  /// Returns a Dart 3 record (updatedParent, updatedChild).\n  static (BaseEntityModel<T>, BaseEntityModel<T>) removeChildAndUpdateChild<\n    T extends Object\n  >(BaseEntityModel<T> parent, BaseEntityModel<T> child",
          "doc": ""
        },
        {
          "name": "return",
          "params": "updatedParent, updatedChild);\n  }\n\n  /// Records a user action in the entity's history efficiently.\n  ///\n  /// [action] - The user action to record.\n  /// [isAccessAction] - Whether this is an access action (vs. modification).\n  /// Returns an updated entity with the action recorded in history.\n  BaseEntityModel<T> recordAction(\n    UserAction action, {\n    bool isAccessAction = false,\n  }",
          "doc": ""
        },
        {
          "name": "while",
          "params": "queue.length > maxSize",
          "doc": ""
        },
        {
          "name": "copyWith",
          "params": "security:\n          isAccessAction\n              ? security.copyWith(accessLog: updatedHistory)\n              : security.copyWith(modHistory: updatedHistory),\n    );\n  }\n\n  /// Increments the entity's version.\n  ///\n  /// [isStructural] - Whether this is a structural change (vs. data-only).\n  /// Returns an updated entity with incremented version numbers.\n  BaseEntityModel<T> incrementVersion({bool isStructural = false}",
          "doc": ""
        }
      ],
      "properties": [
        {
          "name": "path",
          "type": "final",
          "doc": "Creates a new BaseEntityModel instance with its component parts\n  ///\n  /// [core] - Core entity properties and data\n  /// [hierarchy] - Tree structure and relationships\n  /// [security] - Access control and permissions\n  /// [classification] - Tags, categories and workflow information\n  /// [versioning] - Version control and history tracking\n  /// [extraData] - Optional additional typed data\n  const factory BaseEntityModel({\n    /// Core entity data containing essential properties\n    required CoreEntity<T> core,\n\n    /// Component for hierarchy and tree structure\n    required EntityHierarchy hierarchy,\n\n    /// Component for access control and security\n    required EntitySecurity security,\n\n    /// Component for organization and workflow\n    required EntityClassification classification,\n\n    /// Component for change tracking and history\n    required EntityVersioning versioning,\n\n    /// Optional extra data of type T\n    T? extraData,\n  }) = _BaseEntityModel<T>;\n\n  // Delegate core properties\n  /// Unique identifier of the entity\n  EntityId get id => core.id;\n\n  /// Human-readable name of the entity\n  String get name => core.name;\n\n  /// Optional description of the entity\n  String? get description => core.description;\n\n  /// When the entity was created\n  DateTime get createdAt => core.createdAt;\n\n  /// When the entity was last updated\n  DateTime get updatedAt => core.updatedAt;\n\n  /// Schema version of the entity\n  String get schemaVer => core.schemaVer;\n\n  /// Current status of the entity\n  EntityStatus get status => core.status;\n\n  /// Custom metadata for the entity\n  Map<String, Object> get meta => core.meta;\n\n  /// User who owns the entity\n  UserAction get owner => core.owner;\n\n  /// User who created the entity\n  UserAction get creator => core.creator;\n\n  /// User who last modified the entity\n  UserAction get modifier => core.modifier;\n\n  // Component-based property getters\n  /// Access to versioning component\n  EntityVersioning get version => versioning;\n\n  // Core helpers\n  /// String representation of the entity ID\n  String get uid => core.uid;\n\n  /// Type name of the entity data\n  String get type => core.type;\n\n  // Short accessors to reduce verbosity\n  /// Whether this entity is at the root of a hierarchy\n  bool get isRoot => hierarchy.isHierarchyRoot;\n\n  /// Whether this entity is a leaf node (has no children)\n  bool get isLeaf => hierarchy.isHierarchyLeaf;\n\n  /// Path to the parent entity, if any (just the parent ID)\n  String? get parentPath => hierarchy.parentId?.value;\n\n  /// Full path to the parent entity in the hierarchy (excluding this entity's ID)\n  /// Returns null if this entity is root or treePath is not set.\n  String? get parentFullPath {"
        },
        {
          "name": "segments",
          "type": "final",
          "doc": ""
        },
        {
          "name": "now",
          "type": "final",
          "doc": "Adds a child entity relationship, ensuring hierarchy consistency\n  ///\n  /// [childId] - The ID of the child entity to add\n  /// Returns an updated entity with the child added and leaf status updated\n  BaseEntityModel<T> _addChildEntity(EntityId childId) {\n    if (hierarchy.childIds.contains(childId)) return this;\n    return copyWith(hierarchy: hierarchy.addChild(childId));\n  }\n\n  /// Removes a child entity relationship, ensuring hierarchy consistency.\n  ///\n  /// [childId] - The ID of the child entity to remove.\n  /// Returns an updated entity with the child removed and leaf status updated.\n  BaseEntityModel<T> _removeChildEntity(EntityId childId) {\n    if (!hierarchy.childIds.contains(childId)) return this;\n    return copyWith(hierarchy: hierarchy.removeChild(childId));\n  }\n\n  /// Validates and corrects the hierarchy leaf status if needed\n  ///\n  /// This method ensures that the [isHierarchyLeaf] property correctly reflects\n  /// whether the entity has children or not.\n  ///\n  /// Returns an updated entity with corrected leaf status\n  BaseEntityModel<T> validateHierarchyLeafStatus() {\n    return copyWith(hierarchy: hierarchy.validateLeafStatus());\n  }\n\n  /// Creates a new entity with standard configuration or custom components\n  ///\n  /// [id] - Unique identifier for the entity\n  /// [name] - Display name for the entity\n  /// [owner] - User who owns the entity\n  /// [data] - Typed payload data\n  /// [config] - Optional configuration parameters\n  /// [hierarchy] - Optional custom hierarchy component\n  /// [security] - Optional custom security component\n  /// [classification] - Optional custom classification component\n  /// [versioning] - Optional custom versioning component\n  factory BaseEntityModel.create({\n    required EntityId id,\n    required String name,\n    required UserAction owner,\n    required T data,\n    EntityConfig? config,\n    EntityHierarchy? hierarchy,\n    EntitySecurity? security,\n    EntityClassification? classification,\n    EntityVersioning? versioning,\n  }) {"
        },
        {
          "name": "updatedParent",
          "type": "final",
          "doc": "Adds a child to a parent and updates both entities' hierarchy fields for consistency.\n  ///\n  /// Returns a Dart 3 record (updatedParent, updatedChild).\n  static (BaseEntityModel<T>, BaseEntityModel<T>) addChildAndUpdateChild<\n    T extends Object\n  >(BaseEntityModel<T> parent, BaseEntityModel<T> child) {"
        },
        {
          "name": "updatedChild",
          "type": "final",
          "doc": ""
        },
        {
          "name": "updatedParent",
          "type": "final",
          "doc": "Removes a child from a parent and updates both entities' hierarchy fields for consistency.\n  ///\n  /// Returns a Dart 3 record (updatedParent, updatedChild).\n  static (BaseEntityModel<T>, BaseEntityModel<T>) removeChildAndUpdateChild<\n    T extends Object\n  >(BaseEntityModel<T> parent, BaseEntityModel<T> child) {"
        },
        {
          "name": "updatedChild",
          "type": "final",
          "doc": ""
        },
        {
          "name": "isAccessAction",
          "type": "bool",
          "doc": "Records a user action in the entity's history efficiently.\n  ///\n  /// [action] - The user action to record.\n  /// [isAccessAction] - Whether this is an access action (vs. modification).\n  /// Returns an updated entity with the action recorded in history.\n  BaseEntityModel<T> recordAction(\n    UserAction action, {"
        },
        {
          "name": "history",
          "type": "final",
          "doc": ""
        },
        {
          "name": "queue",
          "type": "final",
          "doc": ""
        },
        {
          "name": "updatedHistory",
          "type": "final",
          "doc": ""
        }
      ]
    },
    "EntityMetadata": {
      "file": "lib/src/domain/entities/base_entity.dart",
      "methods": [
        {
          "name": "EntityMetadata",
          "params": "{\n    required String displayName,\n    required String entityType,\n    String? description,\n    DateTime? lastNameUpdate,\n    @Default({}) Map<String, String> searchTerms,\n  }) = _EntityMetadata;\n\n  /// Creates EntityMetadata from a JSON map\n  factory EntityMetadata.fromJson(Map<String, Object> json",
          "doc": "Creates a new EntityMetadata instance\n  ///\n  /// [displayName] - Human-readable display name\n  /// [entityType] - Type classification of the entity\n  /// [description] - Optional description text\n  /// [lastNameUpdate] - When the name was last changed\n  /// [searchTerms] - Key-value pairs for enhanced searching"
        }
      ],
      "properties": []
    },
    "EventDefaults": {
      "file": "lib/src/domain/events/domain_event.dart",
      "methods": [],
      "properties": [
        {
          "name": "version",
          "type": "const",
          "doc": ""
        },
        {
          "name": "isAsync",
          "type": "const",
          "doc": ""
        },
        {
          "name": "tags",
          "type": "const",
          "doc": ""
        }
      ]
    },
    "EventSchemaConfig": {
      "file": "lib/src/domain/events/domain_event.dart",
      "methods": [],
      "properties": [
        {
          "name": "currentVersion",
          "type": "const",
          "doc": ""
        },
        {
          "name": "minVersion",
          "type": "const",
          "doc": ""
        },
        {
          "name": "maxBackwardsCompatible",
          "type": "const",
          "doc": ""
        },
        {
          "name": "supportedVersions",
          "type": "final",
          "doc": ""
        },
        {
          "name": "migrationPaths",
          "type": "final",
          "doc": ""
        }
      ]
    },
    "EventSchema": {
      "file": "lib/src/domain/events/domain_event.dart",
      "methods": [
        {
          "name": "EventSchema",
          "params": "{\n    required String version,\n    required String eventType,\n    required Map<String, String> fields,\n    required Map<String, bool> required,\n    Map<String, Object>? defaults,\n    Map<String, String>? migrations,\n  }) = _EventSchema;\n\n  factory EventSchema.fromJson(Map<String, Object> json",
          "doc": ""
        }
      ],
      "properties": []
    },
    "DomainEventModel": {
      "file": "lib/src/domain/events/domain_event.dart",
      "methods": [
        {
          "name": "DomainEventModel",
          "params": "{\n    // Core event data\n    required EventId id,\n    required EntityId entityId,\n    required String eventType,\n    required DateTime timestamp,\n    required UserAction initiator,\n    required Map<String, Object> changes,\n\n    // Entity context\n    String? entityType,\n    EntityId? aggregateId,\n\n    // Metadata\n    Map<String, Object>? metadata,\n    @Default(EventDefaults.isAsync) bool isAsync,\n    @Default(EventDefaults.tags) List<String> tags,\n\n    // Event chain\n    EventId? correlationId,\n    EventId? causationId,\n    @Default(EventDefaults.version) int version,\n\n    // Status\n    String? status,\n\n    // Schema versioning\n    @Default(EventSchemaConfig.currentVersion) String schemaVersion,\n    Map<String, Object>? schemaChanges,\n    String? previousSchemaVersion,\n\n    // Version vectors for distributed events\n    @Default({}) Map<String, int> schemaVectors,\n  }) = _DomainEventModel;\n\n  factory DomainEventModel.fromJson(Map<String, Object> json",
          "doc": ""
        },
        {
          "name": "DomainEventModel",
          "params": "id: id,\n      entityId: entityId,\n      entityType: entityType,\n      eventType: EventType.created.name,\n      timestamp: action.timestamp,\n      initiator: action,\n      changes: initialData,\n    );\n  }\n\n  factory DomainEventModel.entityUpdated({\n    required EventId id,\n    required EntityId entityId,\n    required String entityType,\n    required UserAction action,\n    required Map<String, Object> changes,\n  }",
          "doc": ""
        },
        {
          "name": "DomainEventModel",
          "params": "id: id,\n      entityId: entityId,\n      entityType: entityType,\n      eventType: EventType.updated.name,\n      timestamp: action.timestamp,\n      initiator: action,\n      changes: changes,\n    );\n  }\n\n  // Relationship events\n  factory DomainEventModel.relationshipChanged({\n    required EventId id,\n    required EntityId entityId,\n    required String entityType,\n    required UserAction action,\n    required String relationshipType,\n    required Map<String, Object> changes,\n  }",
          "doc": ""
        },
        {
          "name": "DomainEventModel",
          "params": "id: id,\n      entityId: entityId,\n      entityType: entityType,\n      eventType: EventType.relationshipChanged.name,\n      timestamp: action.timestamp,\n      initiator: action,\n      changes: changes,\n      metadata: {'relationshipType': relationshipType},\n    );\n  }\n\n  // Status events\n  factory DomainEventModel.statusChanged({\n    required EventId id,\n    required EntityId entityId,\n    required String entityType,\n    required UserAction action,\n    required String oldStatus,\n    required String newStatus,\n  }",
          "doc": ""
        },
        {
          "name": "DomainEventModel",
          "params": "id: id,\n      entityId: entityId,\n      entityType: entityType,\n      eventType: EventType.statusChanged.name,\n      timestamp: action.timestamp,\n      initiator: action,\n      changes: {'oldStatus': oldStatus, 'newStatus': newStatus},\n      status: newStatus,\n    );\n  }\n\n  // Hierarchy events\n  factory DomainEventModel.hierarchyChanged({\n    required EventId id,\n    required EntityId entityId,\n    required String entityType,\n    required UserAction action,\n    required EntityId? oldParentId,\n    required EntityId? newParentId,\n  }",
          "doc": ""
        },
        {
          "name": "DomainEventModel",
          "params": "id: id,\n      entityId: entityId,\n      entityType: entityType,\n      eventType: EventType.hierarchyChanged.name,\n      timestamp: action.timestamp,\n      initiator: action,\n      changes: {\n        'oldParentId': oldParentId?.value ?? '',\n        'newParentId': newParentId?.value ?? '',\n      },\n    );\n  }\n\n  /// Schema validation\n  bool hasValidSchema(",
          "doc": ""
        },
        {
          "name": "isBackwardsCompatible",
          "params": "",
          "doc": ""
        },
        {
          "name": "migrateSchema",
          "params": "String targetVersion",
          "doc": "Domain event interface method for schema migration\n  /// Actual implementation is moved to application layer"
        },
        {
          "name": "UnimplementedError",
          "params": "'Schema migration implementation should be provided by the application layer',\n    );\n  }\n\n  /// Schema version vector operations\n  bool hasVectorConflict(Map<String, int> otherVectors",
          "doc": ""
        },
        {
          "name": "incrementVector",
          "params": "String node",
          "doc": ""
        },
        {
          "name": "copyWith",
          "params": "schemaVectors: vectors);\n  }\n\n  DomainEventModel mergeVectors(Map<String, int> otherVectors",
          "doc": ""
        },
        {
          "name": "for",
          "params": "final entry in otherVectors.entries",
          "doc": ""
        },
        {
          "name": "if",
          "params": "entry.value > current",
          "doc": ""
        }
      ],
      "properties": [
        {
          "name": "minVer",
          "type": "final",
          "doc": "Schema validation\n  bool hasValidSchema() {\n    return EventSchemaConfig.supportedVersions.contains(schemaVersion);\n  }\n\n  bool isBackwardsCompatible() {"
        },
        {
          "name": "paths",
          "type": "final",
          "doc": ""
        },
        {
          "name": "vectors",
          "type": "final",
          "doc": "Domain event interface method for schema migration\n  /// Actual implementation is moved to application layer\n  DomainEventModel migrateSchema(String targetVersion) {\n    throw UnimplementedError(\n      'Schema migration implementation should be provided by the application layer',\n    );\n  }\n\n  /// Schema version vector operations\n  bool hasVectorConflict(Map<String, int> otherVectors) {\n    return otherVectors.entries.any(\n      (entry) =>\n          schemaVectors[entry.key] != null &&\n          schemaVectors[entry.key]! > entry.value,\n    );\n  }\n\n  DomainEventModel incrementVector(String node) {"
        },
        {
          "name": "merged",
          "type": "final",
          "doc": ""
        },
        {
          "name": "current",
          "type": "final",
          "doc": ""
        }
      ]
    },
    "EmailAddress": {
      "file": "lib/src/domain/value_objects/contact_value_objects.dart",
      "methods": [
        {
          "name": "EmailAddress",
          "params": "String value) = _EmailAddress;\n\n  const EmailAddress._();\n\n  bool isValid(",
          "doc": ""
        }
      ],
      "properties": []
    },
    "PhoneNumber": {
      "file": "lib/src/domain/value_objects/contact_value_objects.dart",
      "methods": [
        {
          "name": "PhoneNumber",
          "params": "{\n    required String number,\n    String? countryCode,\n    String? extension,\n  }) = _PhoneNumber;\n\n  const PhoneNumber._();\n\n  String get formatted =>\n      '${countryCode != null ? '+$countryCode ' : ''}$number${extension != null ? ' x$extension' : ''}';\n\n  factory PhoneNumber.fromJson(Map<String, Object> json",
          "doc": ""
        }
      ],
      "properties": []
    },
    "Address": {
      "file": "lib/src/domain/value_objects/contact_value_objects.dart",
      "methods": [
        {
          "name": "Address",
          "params": "{\n    required String street,\n    required String city,\n    required String country,\n    String? state,\n    String? postalCode,\n    double? latitude,\n    double? longitude,\n  }) = _Address;\n\n  const Address._();\n\n  bool get hasCoordinates => latitude != null && longitude != null;\n  String get oneLine =>\n      '$street, $city${state != null ? ', $state' : ''}, $country';\n\n  factory Address.fromJson(Map<String, Object> json",
          "doc": ""
        }
      ],
      "properties": []
    },
    "ContactInfo": {
      "file": "lib/src/domain/value_objects/contact_value_objects.dart",
      "methods": [
        {
          "name": "ContactInfo",
          "params": "{\n    required String contactName,\n    required String companyName,\n    PhoneNumber? phone,\n    EmailAddress? email,\n    Address? address,\n  }) = _ContactInfo;\n\n  const ContactInfo._();\n\n  bool get hasValidContact => email != null || phone != null;\n  String get displayName => companyName;\n\n  factory ContactInfo.fromJson(Map<String, Object> json",
          "doc": ""
        }
      ],
      "properties": []
    },
    "UserAction": {
      "file": "lib/src/domain/value_objects/user_action.dart",
      "methods": [
        {
          "name": "UserAction",
          "params": "{\n    /// Core User Information\n    required String uid,\n    @Default('') String displayName,\n\n    /// Action Metadata\n    required DateTime timestamp,\n    @Default('') String actionType,\n    @Default('') String description,\n\n    /// Context Information\n    @Default('') String entityId,\n    @Default('') String entityType,\n    @Default('') String workflowStage,\n    @Default('') String status,\n    @Default(false) bool isAuthenticated,\n\n    /// Action Details\n    @Default({}) Map<String, Object> changes,\n    @Default({}) Map<String, Object> metadata,\n    @Default([]) List<String> affectedFields,\n\n    /// Validation & Security\n    @Default(false) bool isAuthorized,\n    @Default([]) List<String> permissions,\n    @Default('') String authenticationMethod,\n\n    /// Audit Trail\n    @Default('') String previousValue,\n    @Default('') String newValue,\n    @Default('') String reason,\n    @Default(false) bool isSuccessful,\n    @Default('') String errorMessage,\n\n    /// Related Actions\n    @Default('') String parentActionId,\n    @Default([]) List<String> relatedActionIds,\n\n    /// Event Tracking\n    @Default('') String eventId,\n    @Default('') String eventType,\n    @Default('') String correlationId,\n    @Default('') String causationId,\n    @Default([]) List<String> eventTags,\n    @Default({}) Map<String, Object> eventMetadata,\n  }) = _UserAction;\n\n  factory UserAction.fromJson(Map<String, Object> json",
          "doc": ""
        },
        {
          "name": "UserAction",
          "params": "uid: user.uid,\n      displayName: user.displayName ?? '',\n      timestamp: DateTime.now(),\n      isAuthenticated: true,\n    );\n  }\n\n  /// Creates an anonymous user action\n  factory UserAction.anonymous(",
          "doc": "Creates a user action from auth user\n  factory UserAction.fromAuthUser(AuthUser user) {"
        },
        {
          "name": "UserAction",
          "params": "uid: 'anonymous',\n      timestamp: DateTime.now(),\n      isAuthenticated: false,\n    );\n  }\n\n  /// Creates a system action\n  factory UserAction.system({\n    required String actionType,\n    required String description,\n  }",
          "doc": ""
        }
      ],
      "properties": []
    },
    "Measurement": {
      "file": "lib/src/domain/value_objects/measurement_value_objects.dart",
      "methods": [
        {
          "name": "Measurement",
          "params": "{\n    required double value,\n    required String unit,\n    double? tolerance,\n    DateTime? timestamp,\n  }) = _Measurement;\n\n  const Measurement._();\n\n  bool isWithinTolerance(double target",
          "doc": ""
        }
      ],
      "properties": []
    },
    "Range": {
      "file": "lib/src/domain/value_objects/measurement_value_objects.dart",
      "methods": [
        {
          "name": "Range",
          "params": "{\n    required T min,\n    required T max,\n  }) = _Range<T>;\n\n  const Range._();\n\n  bool contains(T value",
          "doc": ""
        },
        {
          "name": "overlaps",
          "params": "Range<T> other",
          "doc": ""
        }
      ],
      "properties": []
    },
    "Progress": {
      "file": "lib/src/domain/value_objects/status_value_objects.dart",
      "methods": [],
      "properties": []
    },
    "TaskStatus": {
      "file": "lib/src/domain/value_objects/status_value_objects.dart",
      "methods": [],
      "properties": []
    },
    "TimeWindow": {
      "file": "lib/src/domain/value_objects/time_value_objects.dart",
      "methods": [
        {
          "name": "TimeWindow",
          "params": "{\n    required DateTime start,\n    required DateTime end,\n  }) = _TimeWindow;\n\n  const TimeWindow._();\n\n  Duration get duration => end.difference(start);\n  bool contains(DateTime time",
          "doc": ""
        },
        {
          "name": "isActive",
          "params": "",
          "doc": ""
        }
      ],
      "properties": []
    },
    "Schedule": {
      "file": "lib/src/domain/value_objects/time_value_objects.dart",
      "methods": [
        {
          "name": "Schedule",
          "params": "{\n    required TimeWindow window,\n    @Default([]) List<DateTime> breakTimes,\n    @Default(Duration.zero) Duration bufferTime,\n  }) = _Schedule;\n\n  const Schedule._();\n\n  bool isAvailable(DateTime time",
          "doc": ""
        },
        {
          "name": "if",
          "params": "!window.contains(time)) return false;\n    return !breakTimes.any((break_",
          "doc": ""
        }
      ],
      "properties": []
    },
    "EntityId": {
      "file": "lib/src/domain/value_objects/identity_value_objects.dart",
      "methods": [
        {
          "name": "EntityId",
          "params": "String value) = _EntityId;\n\n  factory EntityId.generate(",
          "doc": ""
        },
        {
          "name": "toString",
          "params": "",
          "doc": ""
        }
      ],
      "properties": []
    },
    "EventId": {
      "file": "lib/src/domain/value_objects/identity_value_objects.dart",
      "methods": [
        {
          "name": "EventId",
          "params": "String value) = _EventId;\n\n  factory EventId.generate(",
          "doc": ""
        },
        {
          "name": "toString",
          "params": "",
          "doc": ""
        }
      ],
      "properties": []
    },
    "ReferenceNumber": {
      "file": "lib/src/domain/value_objects/identity_value_objects.dart",
      "methods": [
        {
          "name": "ReferenceNumber",
          "params": "{\n    required String prefix,\n    required int sequence,\n    String? suffix,\n  }) = _ReferenceNumber;\n\n  const ReferenceNumber._();\n\n  String get formatted =>\n      '$prefix-$sequence${suffix != null ? '-$suffix' : ''}';\n\n  static ReferenceNumber parse(String value",
          "doc": ""
        },
        {
          "name": "ReferenceNumber",
          "params": "prefix: parts[0],\n      sequence: int.parse(parts[1]),\n      suffix: parts.length > 2 ? parts[2] : null,\n    );\n  }\n\n  factory ReferenceNumber.fromJson(Map<String, Object?> json",
          "doc": ""
        }
      ],
      "properties": [
        {
          "name": "parts",
          "type": "final",
          "doc": ""
        }
      ]
    },
    "EntityDefaults": {
      "file": "lib/src/domain/core/core_entity.dart",
      "methods": [],
      "properties": [
        {
          "name": "version",
          "type": "String",
          "doc": "Schema version for new entities"
        },
        {
          "name": "status",
          "type": "EntityStatus",
          "doc": "Status for new entities"
        },
        {
          "name": "priority",
          "type": "EntityPriority",
          "doc": "Priority level for new entities"
        },
        {
          "name": "stage",
          "type": "EntityStage",
          "doc": "Workflow stage for new entities"
        },
        {
          "name": "isPublic",
          "type": "bool",
          "doc": "Public visibility setting"
        },
        {
          "name": "accessCount",
          "type": "int",
          "doc": "Access count for new entities"
        },
        {
          "name": "pathSeparator",
          "type": "String",
          "doc": "Path separator character"
        },
        {
          "name": "encodedPathSeparator",
          "type": "String",
          "doc": "URL-encoded path separator"
        },
        {
          "name": "invalidPathChars",
          "type": "String",
          "doc": "Regex pattern for invalid path characters"
        }
      ]
    },
    "TypedMetadata": {
      "file": "lib/src/domain/core/core_entity.dart",
      "methods": [
        {
          "name": "Function",
          "params": "String key,\n    Object? value,\n    Type targetType,\n    Object? error,\n  )?\n  onConversionError;\n\n  TypedMetadata(this._meta, {this.onConversionError});\n\n  /// Checks if metadata contains a key\n  bool containsKey(String key",
          "doc": ""
        },
        {
          "name": "if",
          "params": "value == null) return null;\n\n    try {\n      // Special handling for DateTime\n      if (T == DateTime",
          "doc": "Converts value to specified type with error handling\n  /// [value] - The value to be converted to type T\n  /// [key] - Optional key name for better error reporting\n  /// Returns the converted value or null if conversion fails\n  Object? _convertSafely<T>(Object? value, {String? key}) {"
        },
        {
          "name": "if",
          "params": "value is T",
          "doc": ""
        },
        {
          "name": "assert",
          "params": "(",
          "doc": ""
        },
        {
          "name": "assert",
          "params": "(",
          "doc": ""
        },
        {
          "name": "if",
          "params": "_cache.containsKey(key)) return _cache[key] as T?;\n    if (!_meta.containsKey(key)) return null;\n\n    final value = _convertSafely<T>(_meta[key], key: key);\n    _cache[key] = value;\n    return value;\n  }\n\n  /// Gets string value from metadata \n  /// [key] - The metadata key to retrieve\n  /// [defaultValue] - Value to return if the key doesn't exist or can't be converted\n  /// Returns typed String value or the default value\n  String getString(String key, {String defaultValue = ''}",
          "doc": "Gets typed value from metadata\n  /// [key] - The metadata key to retrieve\n  /// [T] - The target type to convert the value to\n  /// Returns the value converted to type T or null if key doesn't exist or conversion fails\n  Object? _getValueTyped<T>(String key) {"
        },
        {
          "name": "getInt",
          "params": "String key, {int defaultValue = 0}",
          "doc": "Gets integer value from metadata\n  /// [key] - The metadata key to retrieve\n  /// [defaultValue] - Value to return if the key doesn't exist or can't be converted\n  /// Returns typed int value or the default value"
        },
        {
          "name": "getDouble",
          "params": "String key, {double defaultValue = 0.0}",
          "doc": "Gets double value from metadata\n  /// [key] - The metadata key to retrieve\n  /// [defaultValue] - Value to return if the key doesn't exist or can't be converted\n  /// Returns typed double value or the default value"
        },
        {
          "name": "getBool",
          "params": "String key, {bool defaultValue = false}",
          "doc": "Gets boolean value from metadata\n  /// [key] - The metadata key to retrieve\n  /// [defaultValue] - Value to return if the key doesn't exist or can't be converted\n  /// Returns typed boolean value or the default value"
        },
        {
          "name": "return",
          "params": "value != null) ? value as DateTime : defaultValue;\n  }\n\n  /// Gets typed list from metadata\n  /// [key] - The metadata key containing a List to be converted\n  /// Returns a strongly-typed list or null if conversion fails\n  List<R>? getListAs<R>(String key",
          "doc": "Gets DateTime value from metadata\n  /// [key] - The metadata key to retrieve\n  /// [defaultValue] - Value to return if the key doesn't exist or can't be converted\n  /// Returns typed DateTime value or the default value\n  DateTime? getDateTime(String key, {DateTime? defaultValue}) {\n    final value = _getValueTyped<DateTime>(key);"
        },
        {
          "name": "if",
          "params": "!_meta.containsKey(key) || value == null) return null;\n\n    if (value is C",
          "doc": "Gets typed map from metadata\n  /// [key] - The metadata key containing a Map to be converted\n  /// [K] - The key type for the map (must be an Object)\n  /// [V] - The value type for the map\n  /// Returns a strongly-typed map or null if conversion fails\n  Map<K, V>? getMapAs<K extends Object, V>(String key) =>\n      _getCollectionTyped<Map, V, K>(key) as Map<K, V>?;\n\n  /// Handles collection types with error handling\n  /// Ensures all elements match the expected type\n  /// [C] - The collection type (List or Map)\n  /// [V] - The value type (list elements or map values)\n  /// [K] - The key type for maps\n  Object? _getCollectionTyped<C, V, K extends Object>(String key) {\n    final value = _meta[key];"
        },
        {
          "name": "if",
          "params": "C == List && value is List",
          "doc": ""
        },
        {
          "name": "for",
          "params": "final item in value",
          "doc": ""
        },
        {
          "name": "if",
          "params": "item is V",
          "doc": ""
        },
        {
          "name": "if",
          "params": "C == Map && value is Map",
          "doc": ""
        },
        {
          "name": "for",
          "params": "final entry in value.entries",
          "doc": ""
        },
        {
          "name": "if",
          "params": "entry.key is K && entry.value is V",
          "doc": ""
        },
        {
          "name": "if",
          "params": "onConversionError != null",
          "doc": ""
        },
        {
          "name": "if",
          "params": "value is Map<String, Object>",
          "doc": "Gets nested metadata as another TypedMetadata instance\n  /// [key] - The key containing a Map that should be wrapped in TypedMetadata\n  /// Returns null if the value is not a Map`<String, Object>`\n  TypedMetadata? getNestedMetadata(String key) {\n    final value = _meta[key];"
        },
        {
          "name": "TypedMetadata",
          "params": "value);\n    }\n    return null;\n  }\n\n  /// Tries multiple keys in sequence until finding a non-null value\n  /// [keys] - List of keys to try in order\n  /// Returns the first matching value or null if no matches\n  Object? getFirstMatching<T>(List<String> keys",
          "doc": ""
        },
        {
          "name": "for",
          "params": "final key in keys",
          "doc": ""
        },
        {
          "name": "if",
          "params": "value != null) return value;\n    }\n    return null;\n  }\n\n  /// Internal cache for previously converted values\n  final Map<String, Object?> _cache = {};\n\n  /// Clears the entire type conversion cache\n  void clearCache(",
          "doc": ""
        },
        {
          "name": "clearCacheEntry",
          "params": "String key",
          "doc": "Clears a specific entry from the type conversion cache\n  /// [key] - The metadata key whose cached value should be removed"
        }
      ],
      "properties": [
        {
          "name": "_meta",
          "type": "Map<String, Object>",
          "doc": ""
        },
        {
          "name": "dateTime",
          "type": "final",
          "doc": "Checks if metadata contains a key\n  bool containsKey(String key) => _meta.containsKey(key);\n\n  /// Converts value to specified type with error handling\n  /// [value] - The value to be converted to type T\n  /// [key] - Optional key name for better error reporting\n  /// Returns the converted value or null if conversion fails\n  Object? _convertSafely<T>(Object? value, {String? key}) {\n    if (value == null) return null;\n\n    try {\n      // Special handling for DateTime\n      if (T == DateTime) {"
        },
        {
          "name": "value",
          "type": "return",
          "doc": ""
        },
        {
          "name": "true",
          "type": "return",
          "doc": ""
        },
        {
          "name": "null",
          "type": "return",
          "doc": ""
        },
        {
          "name": "true",
          "type": "return",
          "doc": ""
        },
        {
          "name": "null",
          "type": "return",
          "doc": ""
        },
        {
          "name": "value",
          "type": "final",
          "doc": "Gets typed value from metadata\n  /// [key] - The metadata key to retrieve\n  /// [T] - The target type to convert the value to\n  /// Returns the value converted to type T or null if key doesn't exist or conversion fails\n  Object? _getValueTyped<T>(String key) {\n    if (_cache.containsKey(key)) return _cache[key] as T?;\n    if (!_meta.containsKey(key)) return null;"
        },
        {
          "name": "value",
          "type": "return",
          "doc": ""
        },
        {
          "name": "value",
          "type": "final",
          "doc": "Gets string value from metadata \n  /// [key] - The metadata key to retrieve\n  /// [defaultValue] - Value to return if the key doesn't exist or can't be converted\n  /// Returns typed String value or the default value\n  String getString(String key, {String defaultValue = ''}) =>\n      (_getValueTyped<String>(key) ?? defaultValue) as String;\n\n  /// Gets integer value from metadata\n  /// [key] - The metadata key to retrieve\n  /// [defaultValue] - Value to return if the key doesn't exist or can't be converted\n  /// Returns typed int value or the default value\n  int getInt(String key, {int defaultValue = 0}) =>\n      (_getValueTyped<int>(key) ?? defaultValue) as int;\n\n  /// Gets double value from metadata\n  /// [key] - The metadata key to retrieve\n  /// [defaultValue] - Value to return if the key doesn't exist or can't be converted\n  /// Returns typed double value or the default value\n  double getDouble(String key, {double defaultValue = 0.0}) =>\n      (_getValueTyped<double>(key) ?? defaultValue) as double;\n\n  /// Gets boolean value from metadata\n  /// [key] - The metadata key to retrieve\n  /// [defaultValue] - Value to return if the key doesn't exist or can't be converted\n  /// Returns typed boolean value or the default value\n  bool getBool(String key, {bool defaultValue = false}) =>\n      (_getValueTyped<bool>(key) ?? defaultValue) as bool;\n\n  /// Gets DateTime value from metadata\n  /// [key] - The metadata key to retrieve\n  /// [defaultValue] - Value to return if the key doesn't exist or can't be converted\n  /// Returns typed DateTime value or the default value\n  DateTime? getDateTime(String key, {DateTime? defaultValue}) {"
        },
        {
          "name": "value",
          "type": "final",
          "doc": "Gets typed list from metadata\n  /// [key] - The metadata key containing a List to be converted\n  /// Returns a strongly-typed list or null if conversion fails\n  List<R>? getListAs<R>(String key) =>\n      _getCollectionTyped<List, R, Object>(key) as List<R>?;\n\n  /// Gets typed map from metadata\n  /// [key] - The metadata key containing a Map to be converted\n  /// [K] - The key type for the map (must be an Object)\n  /// [V] - The value type for the map\n  /// Returns a strongly-typed map or null if conversion fails\n  Map<K, V>? getMapAs<K extends Object, V>(String key) =>\n      _getCollectionTyped<Map, V, K>(key) as Map<K, V>?;\n\n  /// Handles collection types with error handling\n  /// Ensures all elements match the expected type\n  /// [C] - The collection type (List or Map)\n  /// [V] - The value type (list elements or map values)\n  /// [K] - The key type for maps\n  Object? _getCollectionTyped<C, V, K extends Object>(String key) {"
        },
        {
          "name": "list",
          "type": "final",
          "doc": ""
        },
        {
          "name": "null",
          "type": "return",
          "doc": ""
        },
        {
          "name": "map",
          "type": "final",
          "doc": ""
        },
        {
          "name": "null",
          "type": "return",
          "doc": ""
        },
        {
          "name": "value",
          "type": "return",
          "doc": ""
        },
        {
          "name": "null",
          "type": "return",
          "doc": ""
        },
        {
          "name": "null",
          "type": "return",
          "doc": ""
        },
        {
          "name": "value",
          "type": "final",
          "doc": "Gets nested metadata as another TypedMetadata instance\n  /// [key] - The key containing a Map that should be wrapped in TypedMetadata\n  /// Returns null if the value is not a Map`<String, Object>`\n  TypedMetadata? getNestedMetadata(String key) {"
        },
        {
          "name": "null",
          "type": "return",
          "doc": ""
        },
        {
          "name": "value",
          "type": "final",
          "doc": "Tries multiple keys in sequence until finding a non-null value\n  /// [keys] - List of keys to try in order\n  /// Returns the first matching value or null if no matches\n  Object? getFirstMatching<T>(List<String> keys) {\n    for (final key in keys) {"
        },
        {
          "name": "null",
          "type": "return",
          "doc": ""
        },
        {
          "name": "_cache",
          "type": "Map<String, Object?>",
          "doc": "Internal cache for previously converted values"
        }
      ]
    },
    "CoreEntity": {
      "file": "lib/src/domain/core/core_entity.dart",
      "methods": [
        {
          "name": "CoreEntity",
          "params": "{\n    required EntityId id,\n    required String name,\n    String? description,\n    required DateTime createdAt,\n    required DateTime updatedAt,\n    @Default(EntityDefaults.version) String schemaVer,\n    @Default(EntityDefaults.status) EntityStatus status,\n    @Default({}) Map<String, Object> meta,\n    required UserAction owner,\n    required UserAction creator,\n    required UserAction modifier,\n    T? data,\n  }) = _CoreEntity<T>;\n\n  factory CoreEntity.fromJson(\n    Map<String, Object> json,\n    T Function(Object? json) fromJsonT,",
          "doc": "Base entity class containing core properties and metadata\n  /// [id] - Unique identifier for this entity\n  /// [name] - Human-readable name for this entity\n  /// [createdAt] - Timestamp of entity creation\n  /// [updatedAt] - Timestamp of last update\n  /// [data] - Optional typed payload data"
        },
        {
          "name": "hasMetadata",
          "params": "String key",
          "doc": "Unique identifier string from entity ID\n  String get uid => id.value;\n\n  /// Runtime type of entity data\n  String get type => data?.runtimeType.toString() ?? T.toString();\n\n  /// Type-safe metadata accessor\n  TypedMetadata get typedMeta => TypedMetadata(meta);\n\n  /// Gets typed value from metadata\n  /// [key] - The metadata key to retrieve\n  /// [R] - The target type to convert the value to\n  /// Returns the value converted to type R or null if conversion fails\n  Object? getMetadataAs<R>(String key) => getMetadata<R>(key);\n\n  /// Gets typed value from metadata\n  /// [key] - The metadata key to retrieve\n  /// [R] - The target type to convert the value to\n  /// Returns the value converted to type R or null if conversion fails\n  Object? getMetadata<R>(String key) => _getMetadataTyped<R>(key);\n\n  /// Gets raw value from metadata without type conversion\n  /// [key] - The metadata key to retrieve\n  /// Returns the raw Object value or null if key doesn't exist\n  Object? getMetadataValue(String key) => meta[key];\n\n  /// Checks if metadata contains a key\n  /// [key] - The metadata key to check\n  /// Returns true if the key exists in metadata, false otherwise"
        },
        {
          "name": "filterMetadata",
          "params": "bool Function(String key, Object value) predicate,",
          "doc": "Gets typed metadata with default fallback\n  /// [key] - The metadata key to retrieve\n  /// [defaultValue] - Value to return if the key doesn't exist or can't be converted\n  Object? getMetadataOrDefault<R>(String key, R defaultValue) {\n    return _getMetadataTyped<R>(key) ?? defaultValue;\n  }\n\n  /// Returns filtered metadata based on predicate\n  /// [predicate] - Function that tests each key and value"
        },
        {
          "name": "updateMetadata",
          "params": "Map<String, Object> updates, {\n    List<String>? removeKeys,\n  }",
          "doc": "Creates new instance with updated metadata\n  /// [updates] - Map of key-value pairs to add or update in metadata\n  /// [removeKeys] - Optional list of keys to remove from metadata"
        },
        {
          "name": "if",
          "params": "removeKeys != null",
          "doc": ""
        },
        {
          "name": "for",
          "params": "final key in removeKeys",
          "doc": ""
        },
        {
          "name": "copyWith",
          "params": "meta: updatedMeta);\n  }\n\n  /// Gets typed value from metadata safely\n  Object? _getMetadataTyped<R>(String key",
          "doc": ""
        },
        {
          "name": "if",
          "params": "!meta.containsKey(key)) return null;\n    return typedMeta._convertSafely<R>(meta[key]);\n  }\n\n  /// Gets a core property by name\n  Object? getProperty(String key",
          "doc": ""
        },
        {
          "name": "switch",
          "params": "key",
          "doc": ""
        },
        {
          "name": "if",
          "params": "propertyValue != null",
          "doc": "Provides unified access to properties and metadata\n  /// Properties take precedence over metadata with same key\n  /// Provides unified access to properties and metadata\n  /// Properties take precedence over metadata with same key\n  operator [](String key) {\n    final propertyValue = getProperty(key);"
        }
      ],
      "properties": [
        {
          "name": "updatedMeta",
          "type": "final",
          "doc": "Base entity class containing core properties and metadata\n  /// [id] - Unique identifier for this entity\n  /// [name] - Human-readable name for this entity\n  /// [createdAt] - Timestamp of entity creation\n  /// [updatedAt] - Timestamp of last update\n  /// [data] - Optional typed payload data\n  const factory CoreEntity({\n    required EntityId id,\n    required String name,\n    String? description,\n    required DateTime createdAt,\n    required DateTime updatedAt,\n    @Default(EntityDefaults.version) String schemaVer,\n    @Default(EntityDefaults.status) EntityStatus status,\n    @Default({}) Map<String, Object> meta,\n    required UserAction owner,\n    required UserAction creator,\n    required UserAction modifier,\n    T? data,\n  }) = _CoreEntity<T>;\n\n  factory CoreEntity.fromJson(\n    Map<String, Object> json,\n    T Function(Object? json) fromJsonT,\n  ) => _$CoreEntityFromJson(json, fromJsonT);\n\n  /// Unique identifier string from entity ID\n  String get uid => id.value;\n\n  /// Runtime type of entity data\n  String get type => data?.runtimeType.toString() ?? T.toString();\n\n  /// Type-safe metadata accessor\n  TypedMetadata get typedMeta => TypedMetadata(meta);\n\n  /// Gets typed value from metadata\n  /// [key] - The metadata key to retrieve\n  /// [R] - The target type to convert the value to\n  /// Returns the value converted to type R or null if conversion fails\n  Object? getMetadataAs<R>(String key) => getMetadata<R>(key);\n\n  /// Gets typed value from metadata\n  /// [key] - The metadata key to retrieve\n  /// [R] - The target type to convert the value to\n  /// Returns the value converted to type R or null if conversion fails\n  Object? getMetadata<R>(String key) => _getMetadataTyped<R>(key);\n\n  /// Gets raw value from metadata without type conversion\n  /// [key] - The metadata key to retrieve\n  /// Returns the raw Object value or null if key doesn't exist\n  Object? getMetadataValue(String key) => meta[key];\n\n  /// Checks if metadata contains a key\n  /// [key] - The metadata key to check\n  /// Returns true if the key exists in metadata, false otherwise\n  bool hasMetadata(String key) => meta.containsKey(key);\n\n  /// Gets typed metadata with default fallback\n  /// [key] - The metadata key to retrieve\n  /// [defaultValue] - Value to return if the key doesn't exist or can't be converted\n  Object? getMetadataOrDefault<R>(String key, R defaultValue) {\n    return _getMetadataTyped<R>(key) ?? defaultValue;\n  }\n\n  /// Returns filtered metadata based on predicate\n  /// [predicate] - Function that tests each key and value\n  Map<String, Object> filterMetadata(\n    bool Function(String key, Object value) predicate,\n  ) {\n    return Map.fromEntries(\n      meta.entries.where((entry) => predicate(entry.key, entry.value)),\n    );\n  }\n\n  /// Creates new instance with updated metadata\n  /// [updates] - Map of key-value pairs to add or update in metadata\n  /// [removeKeys] - Optional list of keys to remove from metadata\n  CoreEntity<T> updateMetadata(\n    Map<String, Object> updates, {\n    List<String>? removeKeys,\n  }) {"
        },
        {
          "name": "id",
          "type": "return",
          "doc": "Gets typed value from metadata safely\n  Object? _getMetadataTyped<R>(String key) {\n    if (!meta.containsKey(key)) return null;\n    return typedMeta._convertSafely<R>(meta[key]);\n  }\n\n  /// Gets a core property by name\n  Object? getProperty(String key) {\n    switch (key) {\n      case 'id':"
        },
        {
          "name": "name",
          "type": "return",
          "doc": ""
        },
        {
          "name": "description",
          "type": "return",
          "doc": ""
        },
        {
          "name": "createdAt",
          "type": "return",
          "doc": ""
        },
        {
          "name": "updatedAt",
          "type": "return",
          "doc": ""
        },
        {
          "name": "schemaVer",
          "type": "return",
          "doc": ""
        },
        {
          "name": "status",
          "type": "return",
          "doc": ""
        },
        {
          "name": "owner",
          "type": "return",
          "doc": ""
        },
        {
          "name": "creator",
          "type": "return",
          "doc": ""
        },
        {
          "name": "modifier",
          "type": "return",
          "doc": ""
        },
        {
          "name": "data",
          "type": "return",
          "doc": ""
        },
        {
          "name": "null",
          "type": "return",
          "doc": ""
        },
        {
          "name": "propertyValue",
          "type": "final",
          "doc": "Provides unified access to properties and metadata\n  /// Properties take precedence over metadata with same key\n  /// Provides unified access to properties and metadata\n  /// Properties take precedence over metadata with same key\n  operator [](String key) {"
        },
        {
          "name": "propertyValue",
          "type": "return",
          "doc": ""
        }
      ]
    },
    "EntityConfigDefaults": {
      "file": "lib/src/domain/core/entity_config.dart",
      "methods": [],
      "properties": [
        {
          "name": "configVersion",
          "type": "String",
          "doc": "Schema version for config entities"
        },
        {
          "name": "maxPathLength",
          "type": "int",
          "doc": "Maximum length of entity path in characters"
        },
        {
          "name": "maxPathSegment",
          "type": "int",
          "doc": "Maximum length of path segment"
        },
        {
          "name": "maxHierarchyDepth",
          "type": "int",
          "doc": "Maximum depth of entity hierarchies"
        },
        {
          "name": "maxHistorySize",
          "type": "int",
          "doc": "Maximum number of history entries to retain"
        },
        {
          "name": "defaultHistorySize",
          "type": "int",
          "doc": "Default number of history entries to show in views"
        },
        {
          "name": "defaultLockTimeout",
          "type": "Duration",
          "doc": "Default duration before a lock expires"
        },
        {
          "name": "lockExtensionPeriod",
          "type": "Duration",
          "doc": "Duration by which a lock can be extended"
        },
        {
          "name": "minLockDuration",
          "type": "Duration",
          "doc": "Minimum duration for which an entity can be locked"
        },
        {
          "name": "maxLockDuration",
          "type": "Duration",
          "doc": "Maximum duration for which an entity can be locked"
        },
        {
          "name": "defaultVersion",
          "type": "String",
          "doc": "Default version string for new entities"
        },
        {
          "name": "defaultIsPublic",
          "type": "bool",
          "doc": "Default public visibility setting"
        },
        {
          "name": "defaultPriority",
          "type": "EntityPriority",
          "doc": "Default priority level for new entities"
        },
        {
          "name": "defaultStage",
          "type": "EntityStage",
          "doc": "Default workflow stage for new entities"
        },
        {
          "name": "pathSeparator",
          "type": "String",
          "doc": "Character used to separate path segments"
        },
        {
          "name": "invalidPathChars",
          "type": "String",
          "doc": "Regular expression pattern for invalid path characters"
        }
      ]
    },
    "EntityConfig": {
      "file": "lib/src/domain/core/entity_config.dart",
      "methods": [
        {
          "name": "EntityConfig",
          "params": "{\n    /// Configuration schema version for tracking changes to the configuration format itself\n    @Default(EntityConfigDefaults.configVersion) String configVersion,\n\n    // Path limits\n    /// Maximum length of an entity path in characters.\n    @Default(EntityConfigDefaults.maxPathLength) int maxPathLength,\n\n    /// Maximum length of a single path segment in characters.\n    @Default(EntityConfigDefaults.maxPathSegment) int maxPathSegment,\n\n    /// Maximum allowed depth of entity hierarchies.\n    @Default(EntityConfigDefaults.maxHierarchyDepth) int maxHierarchyDepth,\n\n    // History limits\n    /// Maximum number of history entries to retain per entity.\n    @Default(EntityConfigDefaults.maxHistorySize) int maxHistorySize,\n\n    /// Default number of history entries to show in views.\n    @Default(EntityConfigDefaults.defaultHistorySize) int defaultHistorySize,\n\n    // Lock settings\n    /// Default duration before an entity lock expires.\n    @Default(EntityConfigDefaults.defaultLockTimeout)\n    Duration defaultLockTimeout,\n\n    /// Duration by which a lock can be extended.\n    @Default(EntityConfigDefaults.lockExtensionPeriod)\n    Duration lockExtensionPeriod,\n\n    /// Minimum duration for which an entity can be locked.\n    @Default(EntityConfigDefaults.minLockDuration) Duration minLockDuration,\n\n    /// Maximum duration for which an entity can be locked.\n    @Default(EntityConfigDefaults.maxLockDuration) Duration maxLockDuration,\n\n    // Entity defaults\n    /// Default version string for new entities.\n    @Default(EntityConfigDefaults.defaultVersion) String defaultVersion,\n\n    /// Whether entities are public by default.\n    @Default(EntityConfigDefaults.defaultIsPublic) bool defaultIsPublic,\n\n    /// Default priority level for new entities.\n    @Default(EntityConfigDefaults.defaultPriority)\n    EntityPriority defaultPriority,\n\n    /// Default workflow stage for new entities.\n    @Default(EntityConfigDefaults.defaultStage) EntityStage defaultStage,\n\n    // Path settings\n    /// Character used to separate path segments.\n    @Default(EntityConfigDefaults.pathSeparator) String pathSeparator,\n\n    /// Regular expression pattern defining invalid characters in paths.\n    @Default(EntityConfigDefaults.invalidPathChars) String invalidPathChars,\n  }) = _EntityConfig;\n\n  /// Creates a new instance of [EntityConfig] with configuration optimized for development\n  ///\n  /// This configuration has more permissive settings than the default\n  factory EntityConfig.development(",
          "doc": ""
        },
        {
          "name": "EntityConfig",
          "params": "configVersion: configVersion ?? defaultConfig.configVersion,\n      maxPathLength: maxPathLength ?? defaultConfig.maxPathLength,\n      maxPathSegment: maxPathSegment ?? defaultConfig.maxPathSegment,\n      maxHierarchyDepth: maxHierarchyDepth ?? defaultConfig.maxHierarchyDepth,\n      maxHistorySize: maxHistorySize ?? defaultConfig.maxHistorySize,\n      defaultHistorySize:\n          defaultHistorySize ?? defaultConfig.defaultHistorySize,\n      defaultLockTimeout:\n          defaultLockTimeout ?? defaultConfig.defaultLockTimeout,\n      lockExtensionPeriod:\n          lockExtensionPeriod ?? defaultConfig.lockExtensionPeriod,\n      minLockDuration: minLockDuration ?? defaultConfig.minLockDuration,\n      maxLockDuration: maxLockDuration ?? defaultConfig.maxLockDuration,\n      defaultVersion: defaultVersion ?? defaultConfig.defaultVersion,\n      defaultIsPublic: defaultIsPublic ?? defaultConfig.defaultIsPublic,\n      defaultPriority: defaultPriority ?? defaultConfig.defaultPriority,\n      defaultStage: defaultStage ?? defaultConfig.defaultStage,\n      pathSeparator: pathSeparator ?? defaultConfig.pathSeparator,\n      invalidPathChars: invalidPathChars ?? defaultConfig.invalidPathChars,\n    );\n  }\n\n  factory EntityConfig.fromJson(Map<String, Object?> json",
          "doc": "Creates a new instance of [EntityConfig] with configuration optimized for production\n  ///\n  /// This configuration has more restrictive settings than the default\n  factory EntityConfig.production() {\n    return const EntityConfig(\n      configVersion: '1.0.0',\n      maxPathLength: 512,\n      maxPathSegment: 128,\n      maxHierarchyDepth: 8,\n      maxHistorySize: 25,\n      defaultHistorySize: 10,\n      defaultLockTimeout: Duration(minutes: 10),\n      maxLockDuration: Duration(hours: 12),\n      defaultIsPublic: false,\n    );\n  }\n\n  /// Creates a new instance of [EntityConfig] with custom overrides.\n  ///\n  /// This factory allows you to define configuration settings for any environment (e.g., staging, testing, CI)\n  /// by overriding only the fields you need. All unspecified fields will use the default values.\n  ///\n  /// Example:\n  /// ```dart\n  /// final stagingConfig = EntityConfig.custom(\n  ///   maxPathLength: 1500,\n  ///   defaultIsPublic: false,\n  /// );\n  /// ```\n  factory EntityConfig.custom({\n    String? configVersion,\n    int? maxPathLength,\n    int? maxPathSegment,\n    int? maxHierarchyDepth,\n    int? maxHistorySize,\n    int? defaultHistorySize,\n    Duration? defaultLockTimeout,\n    Duration? lockExtensionPeriod,\n    Duration? minLockDuration,\n    Duration? maxLockDuration,\n    String? defaultVersion,\n    bool? defaultIsPublic,\n    EntityPriority? defaultPriority,\n    EntityStage? defaultStage,\n    String? pathSeparator,\n    String? invalidPathChars,\n  }) {\n    const defaultConfig = EntityConfig();"
        },
        {
          "name": "isValidPath",
          "params": "String path",
          "doc": "Validates if a path string conforms to the configuration constraints\n  ///\n  /// Returns true if the path is valid according to all path constraints"
        },
        {
          "name": "if",
          "params": "path.length > maxPathLength) return false;\n\n    // Check path segments\n    final segments = path.split(pathSeparator);\n\n    // Check hierarchy depth\n    if (segments.length > maxHierarchyDepth) return false;\n\n    // Check each segment\n    for (final segment in segments",
          "doc": ""
        },
        {
          "name": "if",
          "params": "segment.isEmpty) continue;\n\n      // Check segment length\n      if (segment.length > maxPathSegment) return false;\n\n      // Check for invalid characters\n      if (RegExp(invalidPathChars).hasMatch(segment)) return false;\n    }\n\n    return true;\n  }\n\n  /// Sanitizes a path to conform to configuration constraints.\n  ///\n  /// This method removes invalid characters, truncates paths and segments\n  /// that exceed maximum length.\n  ///\n  /// Returns a sanitized path that conforms to configuration constraints.\n  String sanitizePath(String path",
          "doc": ""
        },
        {
          "name": "for",
          "params": "int i = 0; i < segments.length; i++",
          "doc": ""
        },
        {
          "name": "if",
          "params": "segments[i].length > maxPathSegment",
          "doc": ""
        },
        {
          "name": "if",
          "params": "segments.length > maxHierarchyDepth",
          "doc": ""
        },
        {
          "name": "if",
          "params": "result.length > maxPathLength",
          "doc": ""
        },
        {
          "name": "joinPath",
          "params": "List<String> segments",
          "doc": "Joins path segments using the configured path separator.\n  ///\n  /// This is a convenience method that ensures consistent path formatting.\n  /// It also sanitizes the result to ensure it conforms to all path constraints.\n  ///\n  /// Returns the joined path, sanitized according to configuration constraints."
        },
        {
          "name": "sanitizePath",
          "params": "joined);\n  }\n\n  /// Resolves a child path relative to a parent path.\n  ///\n  /// This ensures proper joining of paths using the configured path separator.\n  ///\n  /// Returns the full path to the child, sanitized according to configuration constraints.\n  String resolvePath(String parent, String child",
          "doc": ""
        },
        {
          "name": "if",
          "params": "parent.endsWith(pathSeparator)",
          "doc": ""
        },
        {
          "name": "if",
          "params": "child.startsWith(pathSeparator)",
          "doc": ""
        },
        {
          "name": "sanitizePath",
          "params": "'$parent$pathSeparator$child');\n  }\n\n  /// Calculates the depth of a path based on the number of separators.\n  ///\n  /// Returns the hierarchy level (depth) of the path.\n  int getPathDepth(String path",
          "doc": ""
        },
        {
          "name": "if",
          "params": "trimmedPath.isEmpty) return 0;\n\n    final segments =\n        trimmedPath.split(pathSeparator).where((s",
          "doc": ""
        },
        {
          "name": "isValidLockDuration",
          "params": "Duration lockDuration",
          "doc": "Validates that a lock duration is within the configured limits.\n  ///\n  /// Returns true if the duration is between minLockDuration and maxLockDuration."
        },
        {
          "name": "constrainLockDuration",
          "params": "Duration lockDuration",
          "doc": "Adjusts a lock duration to fit within the configured limits.\n  ///\n  /// If the input duration is too short, returns minLockDuration.\n  /// If the input duration is too long, returns maxLockDuration.\n  /// Otherwise, returns the original duration."
        },
        {
          "name": "if",
          "params": "lockDuration < minLockDuration) return minLockDuration;\n    if (lockDuration > maxLockDuration) return maxLockDuration;\n    return lockDuration;\n  }\n\n  /// Normalizes a path by removing redundant separators and ensuring constraints\n  ///\n  /// Returns a normalized path string.\n  String normalizePath(String path",
          "doc": ""
        },
        {
          "name": "if",
          "params": "path.isEmpty) return '';\n\n    // Split into segments and filter out empty ones (that come from consecutive separators)\n    final segments =\n        path\n            .split(pathSeparator)\n            .where((segment",
          "doc": ""
        },
        {
          "name": "sanitizePath",
          "params": "segments.join(pathSeparator));\n  }\n\n  /// Extracts the parent path from a given path.\n  ///\n  /// Returns the parent path, or an empty string if the path has no parent.\n  String getParentPath(String path",
          "doc": ""
        },
        {
          "name": "if",
          "params": "lastSeparatorIndex <= 0",
          "doc": ""
        },
        {
          "name": "getNameFromPath",
          "params": "String path",
          "doc": "Extracts the last segment (name) from a path.\n  ///\n  /// Returns the name component, or the full path if there are no separators."
        },
        {
          "name": "if",
          "params": "lastSeparatorIndex < 0",
          "doc": ""
        },
        {
          "name": "isParentPath",
          "params": "String parentPath, String childPath",
          "doc": "Checks if one path is a parent of another path.\n  ///\n  /// Returns true if parentPath is a parent of childPath."
        },
        {
          "name": "if",
          "params": "normalizedParent.isEmpty",
          "doc": ""
        },
        {
          "name": "isValidEntityName",
          "params": "String name",
          "doc": "Validates an entity name based on configuration constraints.\n  ///\n  /// Returns true if the name:\n  /// - Is not empty\n  /// - Does not contain path separators\n  /// - Does not contain invalid characters\n  /// - Does not exceed maxPathSegment length"
        },
        {
          "name": "if",
          "params": "name.isEmpty) return false;\n    if (name.length > maxPathSegment) return false;\n    if (name.contains(pathSeparator)) return false;\n    if (RegExp(invalidPathChars).hasMatch(name)) return false;\n    return true;\n  }\n\n  /// Validates configuration values to ensure they are reasonable and consistent.\n  ///\n  /// Returns true if the configuration is valid.\n  bool validate(",
          "doc": ""
        },
        {
          "name": "if",
          "params": "maxPathLength <= 0) return false;\n    if (maxPathSegment <= 0) return false;\n    if (maxHierarchyDepth <= 0) return false;\n    if (maxHistorySize < 0) return false;\n    if (defaultHistorySize < 0 || defaultHistorySize > maxHistorySize",
          "doc": ""
        },
        {
          "name": "if",
          "params": "defaultLockTimeout.isNegative) return false;\n    if (lockExtensionPeriod.isNegative) return false;\n    if (minLockDuration.isNegative) return false;\n    if (maxLockDuration.isNegative) return false;\n    if (minLockDuration > maxLockDuration) return false;\n    if (pathSeparator.isEmpty) return false;\n\n    // Try to compile the regex pattern to check validity\n    try {\n      RegExp(invalidPathChars);\n    } catch (e",
          "doc": ""
        },
        {
          "name": "if",
          "params": "defaultVersion != other.defaultVersion",
          "doc": "Compares this configuration with another to identify differences.\n  ///\n  /// Returns a Map with property names as keys and a sub-map with 'this' and 'other' values\n  /// for each property that differs. Returns an empty map if the configurations are identical.\n  Map<String, Map<String, Object>> compareWith(EntityConfig other) {\n    final differences = <String, Map<String, Object>>{};\n\n    // Compare versions"
        },
        {
          "name": "if",
          "params": "maxPathLength != other.maxPathLength",
          "doc": ""
        },
        {
          "name": "if",
          "params": "maxPathSegment != other.maxPathSegment",
          "doc": ""
        },
        {
          "name": "if",
          "params": "maxHierarchyDepth != other.maxHierarchyDepth",
          "doc": ""
        },
        {
          "name": "if",
          "params": "maxHistorySize != other.maxHistorySize",
          "doc": ""
        },
        {
          "name": "if",
          "params": "defaultHistorySize != other.defaultHistorySize",
          "doc": ""
        },
        {
          "name": "if",
          "params": "defaultLockTimeout != other.defaultLockTimeout",
          "doc": ""
        },
        {
          "name": "if",
          "params": "lockExtensionPeriod != other.lockExtensionPeriod",
          "doc": ""
        },
        {
          "name": "if",
          "params": "minLockDuration != other.minLockDuration",
          "doc": ""
        },
        {
          "name": "if",
          "params": "maxLockDuration != other.maxLockDuration",
          "doc": ""
        },
        {
          "name": "if",
          "params": "defaultVersion != other.defaultVersion",
          "doc": ""
        },
        {
          "name": "if",
          "params": "defaultIsPublic != other.defaultIsPublic",
          "doc": ""
        },
        {
          "name": "if",
          "params": "defaultPriority != other.defaultPriority",
          "doc": ""
        },
        {
          "name": "if",
          "params": "defaultStage != other.defaultStage",
          "doc": ""
        },
        {
          "name": "if",
          "params": "pathSeparator != other.pathSeparator",
          "doc": ""
        },
        {
          "name": "if",
          "params": "invalidPathChars != other.invalidPathChars",
          "doc": ""
        },
        {
          "name": "isCompatibleWith",
          "params": "EntityConfig other",
          "doc": "Checks if this configuration is compatible with another configuration.\n  ///\n  /// A configuration is considered compatible when:\n  /// 1. Its path limits are equal to or greater than the other configuration\n  /// 2. It uses the same path separator character\n  /// 3. Its lock duration constraints can accommodate the other's default lock duration\n  ///\n  /// Returns true if this configuration is compatible with the other configuration."
        },
        {
          "name": "if",
          "params": "maxPathLength < other.maxPathLength) return false;\n    if (maxPathSegment < other.maxPathSegment) return false;\n    if (maxHierarchyDepth < other.maxHierarchyDepth) return false;\n    if (pathSeparator != other.pathSeparator) return false;\n\n    // Lock duration compatibility\n    if (other.defaultLockTimeout < minLockDuration) return false;\n    if (other.defaultLockTimeout > maxLockDuration) return false;\n\n    // Compatible with associated defaults\n    if (maxHistorySize < other.defaultHistorySize) return false;\n\n    return true;\n  }\n\n  /// Creates a merged configuration using the most permissive values from both configurations\n  ///\n  /// This is useful when you need to ensure compatibility between two environments\n  ///\n  /// Returns a new EntityConfig that will be compatible with both source configurations\n  EntityConfig mergeWith(EntityConfig other",
          "doc": ""
        },
        {
          "name": "EntityConfig",
          "params": "// Take the larger value for limits\n      maxPathLength: math.max(maxPathLength, other.maxPathLength),\n      maxPathSegment: math.max(maxPathSegment, other.maxPathSegment),\n      maxHierarchyDepth: math.max(maxHierarchyDepth, other.maxHierarchyDepth),\n      maxHistorySize: math.max(maxHistorySize, other.maxHistorySize),\n      defaultHistorySize: math.min(\n        math.max(defaultHistorySize, other.defaultHistorySize),\n        math.max(maxHistorySize, other.maxHistorySize),\n      ),\n\n      // Take the wider ranges for durations\n      defaultLockTimeout: Duration(\n        milliseconds:\n            (defaultLockTimeout.inMilliseconds +\n                other.defaultLockTimeout.inMilliseconds) ~/\n            2,\n      ),\n      lockExtensionPeriod: Duration(\n        milliseconds: math.max(\n          lockExtensionPeriod.inMilliseconds,\n          other.lockExtensionPeriod.inMilliseconds,\n        ),\n      ),\n      minLockDuration: Duration(\n        milliseconds: math.min(\n          minLockDuration.inMilliseconds,\n          other.minLockDuration.inMilliseconds,\n        ),\n      ),\n      maxLockDuration: Duration(\n        milliseconds: math.max(\n          maxLockDuration.inMilliseconds,\n          other.maxLockDuration.inMilliseconds,\n        ),\n      ),\n\n      // Preserve path separator from this config (they should be the same for compatibility)\n      pathSeparator: pathSeparator,\n\n      // Use most permissive regex pattern for invalid chars (if they differ)\n      invalidPathChars:\n          invalidPathChars == other.invalidPathChars\n              ? invalidPathChars\n              : _mergeInvalidCharsPatterns(\n                invalidPathChars,\n                other.invalidPathChars,\n              ),\n\n      // Use newest schema version\n      defaultVersion:\n          _compareVersions(defaultVersion, other.defaultVersion) >= 0\n              ? defaultVersion\n              : other.defaultVersion,\n\n      // Keep other settings from this config\n      defaultIsPublic: defaultIsPublic,\n      defaultPriority: defaultPriority,\n      defaultStage: defaultStage,\n    );\n  }\n\n  /// Helper method to merge two regex patterns for invalid characters,\n  /// creating a more permissive pattern that allows characters valid in either pattern.\n  static String _mergeInvalidCharsPatterns(String pattern1, String pattern2",
          "doc": ""
        },
        {
          "name": "if",
          "params": "pattern1 == pattern2) return pattern1;\n\n      // Simple approach: just use the more restrictive pattern\n      // A more complete approach would parse and merge the character sets\n      if (pattern1.length > pattern2.length) return pattern2;\n      return pattern1;\n    } catch (e",
          "doc": ""
        },
        {
          "name": "_compareVersions",
          "params": "String v1, String v2",
          "doc": "Helper method to compare semantic version strings.\n  /// Returns positive if v1 > v2, negative if v1 < v2, 0 if equal."
        },
        {
          "name": "for",
          "params": "var i = 0; i < math.min(v1Parts.length, v2Parts.length); i++",
          "doc": ""
        },
        {
          "name": "if",
          "params": "diff != 0) return diff;\n      }\n\n      return v1Parts.length - v2Parts.length;\n    } catch (e",
          "doc": ""
        },
        {
          "name": "isVersionCompatible",
          "params": "String otherVersion, [String? thisVersion]",
          "doc": "Checks if this configuration version is compatible with another version.\n  ///\n  /// [otherVersion] - Version string to check compatibility with (e.g., \"1.2.3\")\n  /// [thisVersion] - Optional version to check, defaults to this config's version\n  ///\n  /// Returns true if versions are compatible."
        },
        {
          "name": "if",
          "params": "version == otherVersion) return true;\n\n    try {\n      final vParts = version.split('.').map(int.parse).toList();\n      final otherParts = otherVersion.split('.').map(int.parse).toList();\n\n      // Major versions must match (breaking changes)\n      if (vParts.isNotEmpty &&\n          otherParts.isNotEmpty &&\n          vParts[0] != otherParts[0]",
          "doc": ""
        },
        {
          "name": "if",
          "params": "vParts.length > 1 && otherParts.length > 1",
          "doc": ""
        },
        {
          "name": "if",
          "params": "vParts[1] < otherParts[1]) return false;\n      }\n\n      // Patch versions don't affect compatibility\n      return true;\n    } catch (e",
          "doc": ""
        },
        {
          "name": "incrementVersion",
          "params": "String increment, [String? baseVersion]",
          "doc": "Creates a new version string following semantic versioning.\n  ///\n  /// [increment] - Which part to increment: \"major\", \"minor\", or \"patch\"\n  /// [baseVersion] - Optional base version, defaults to this config's version"
        },
        {
          "name": "if",
          "params": "parts.length != 3",
          "doc": ""
        },
        {
          "name": "switch",
          "params": "increment.toLowerCase()",
          "doc": ""
        },
        {
          "name": "withIncrementedVersion",
          "params": "String increment",
          "doc": "Creates a new config with the version number incremented.\n  ///\n  /// This creates a new configuration with an updated version while\n  /// preserving all other settings.\n  ///\n  /// [increment] - Which part to increment: \"major\", \"minor\", or \"patch\"\n  ///\n  /// Returns a new EntityConfig with the updated version."
        }
      ],
      "properties": [
        {
          "name": "defaultConfig",
          "type": "const",
          "doc": "Configuration schema version for tracking changes to the configuration format itself\n    @Default(EntityConfigDefaults.configVersion) String configVersion,\n\n    // Path limits\n    /// Maximum length of an entity path in characters.\n    @Default(EntityConfigDefaults.maxPathLength) int maxPathLength,\n\n    /// Maximum length of a single path segment in characters.\n    @Default(EntityConfigDefaults.maxPathSegment) int maxPathSegment,\n\n    /// Maximum allowed depth of entity hierarchies.\n    @Default(EntityConfigDefaults.maxHierarchyDepth) int maxHierarchyDepth,\n\n    // History limits\n    /// Maximum number of history entries to retain per entity.\n    @Default(EntityConfigDefaults.maxHistorySize) int maxHistorySize,\n\n    /// Default number of history entries to show in views.\n    @Default(EntityConfigDefaults.defaultHistorySize) int defaultHistorySize,\n\n    // Lock settings\n    /// Default duration before an entity lock expires.\n    @Default(EntityConfigDefaults.defaultLockTimeout)\n    Duration defaultLockTimeout,\n\n    /// Duration by which a lock can be extended.\n    @Default(EntityConfigDefaults.lockExtensionPeriod)\n    Duration lockExtensionPeriod,\n\n    /// Minimum duration for which an entity can be locked.\n    @Default(EntityConfigDefaults.minLockDuration) Duration minLockDuration,\n\n    /// Maximum duration for which an entity can be locked.\n    @Default(EntityConfigDefaults.maxLockDuration) Duration maxLockDuration,\n\n    // Entity defaults\n    /// Default version string for new entities.\n    @Default(EntityConfigDefaults.defaultVersion) String defaultVersion,\n\n    /// Whether entities are public by default.\n    @Default(EntityConfigDefaults.defaultIsPublic) bool defaultIsPublic,\n\n    /// Default priority level for new entities.\n    @Default(EntityConfigDefaults.defaultPriority)\n    EntityPriority defaultPriority,\n\n    /// Default workflow stage for new entities.\n    @Default(EntityConfigDefaults.defaultStage) EntityStage defaultStage,\n\n    // Path settings\n    /// Character used to separate path segments.\n    @Default(EntityConfigDefaults.pathSeparator) String pathSeparator,\n\n    /// Regular expression pattern defining invalid characters in paths.\n    @Default(EntityConfigDefaults.invalidPathChars) String invalidPathChars,\n  }) = _EntityConfig;\n\n  /// Creates a new instance of [EntityConfig] with configuration optimized for development\n  ///\n  /// This configuration has more permissive settings than the default\n  factory EntityConfig.development() {\n    return const EntityConfig(\n      configVersion: '1.0.0',\n      maxPathLength: 2048,\n      maxHistorySize: 100,\n      defaultLockTimeout: Duration(hours: 1),\n      minLockDuration: Duration(seconds: 5),\n      maxLockDuration: Duration(hours: 48),\n    );\n  }\n\n  /// Creates a new instance of [EntityConfig] with configuration optimized for production\n  ///\n  /// This configuration has more restrictive settings than the default\n  factory EntityConfig.production() {\n    return const EntityConfig(\n      configVersion: '1.0.0',\n      maxPathLength: 512,\n      maxPathSegment: 128,\n      maxHierarchyDepth: 8,\n      maxHistorySize: 25,\n      defaultHistorySize: 10,\n      defaultLockTimeout: Duration(minutes: 10),\n      maxLockDuration: Duration(hours: 12),\n      defaultIsPublic: false,\n    );\n  }\n\n  /// Creates a new instance of [EntityConfig] with custom overrides.\n  ///\n  /// This factory allows you to define configuration settings for any environment (e.g., staging, testing, CI)\n  /// by overriding only the fields you need. All unspecified fields will use the default values.\n  ///\n  /// Example:\n  /// ```dart\n  /// final stagingConfig = EntityConfig.custom(\n  ///   maxPathLength: 1500,\n  ///   defaultIsPublic: false,\n  /// );\n  /// ```\n  factory EntityConfig.custom({\n    String? configVersion,\n    int? maxPathLength,\n    int? maxPathSegment,\n    int? maxHierarchyDepth,\n    int? maxHistorySize,\n    int? defaultHistorySize,\n    Duration? defaultLockTimeout,\n    Duration? lockExtensionPeriod,\n    Duration? minLockDuration,\n    Duration? maxLockDuration,\n    String? defaultVersion,\n    bool? defaultIsPublic,\n    EntityPriority? defaultPriority,\n    EntityStage? defaultStage,\n    String? pathSeparator,\n    String? invalidPathChars,\n  }) {"
        },
        {
          "name": "segments",
          "type": "final",
          "doc": "Validates if a path string conforms to the configuration constraints\n  ///\n  /// Returns true if the path is valid according to all path constraints\n  bool isValidPath(String path) {\n    // Check total path length\n    if (path.length > maxPathLength) return false;\n\n    // Check path segments"
        },
        {
          "name": "true",
          "type": "return",
          "doc": ""
        },
        {
          "name": "result",
          "type": "String",
          "doc": "Sanitizes a path to conform to configuration constraints.\n  ///\n  /// This method removes invalid characters, truncates paths and segments\n  /// that exceed maximum length.\n  ///\n  /// Returns a sanitized path that conforms to configuration constraints.\n  String sanitizePath(String path) {\n    // Start with the original path"
        },
        {
          "name": "segments",
          "type": "final",
          "doc": ""
        },
        {
          "name": "result",
          "type": "return",
          "doc": ""
        },
        {
          "name": "joined",
          "type": "final",
          "doc": "Joins path segments using the configured path separator.\n  ///\n  /// This is a convenience method that ensures consistent path formatting.\n  /// It also sanitizes the result to ensure it conforms to all path constraints.\n  ///\n  /// Returns the joined path, sanitized according to configuration constraints.\n  String joinPath(List<String> segments) {"
        },
        {
          "name": "trimmedPath",
          "type": "final",
          "doc": "Resolves a child path relative to a parent path.\n  ///\n  /// This ensures proper joining of paths using the configured path separator.\n  ///\n  /// Returns the full path to the child, sanitized according to configuration constraints.\n  String resolvePath(String parent, String child) {\n    // Remove trailing separators from parent\n    if (parent.endsWith(pathSeparator)) {\n      parent = parent.substring(0, parent.length - pathSeparator.length);\n    }\n\n    // Remove leading separators from child\n    if (child.startsWith(pathSeparator)) {\n      child = child.substring(pathSeparator.length);\n    }\n\n    return sanitizePath('$parent$pathSeparator$child');\n  }\n\n  /// Calculates the depth of a path based on the number of separators.\n  ///\n  /// Returns the hierarchy level (depth) of the path.\n  int getPathDepth(String path) {\n    // Count separators, accounting for leading/trailing separators"
        },
        {
          "name": "segments",
          "type": "final",
          "doc": ""
        },
        {
          "name": "lockDuration",
          "type": "return",
          "doc": "Validates that a lock duration is within the configured limits.\n  ///\n  /// Returns true if the duration is between minLockDuration and maxLockDuration.\n  bool isValidLockDuration(Duration lockDuration) {\n    return lockDuration >= minLockDuration && lockDuration <= maxLockDuration;\n  }\n\n  /// Adjusts a lock duration to fit within the configured limits.\n  ///\n  /// If the input duration is too short, returns minLockDuration.\n  /// If the input duration is too long, returns maxLockDuration.\n  /// Otherwise, returns the original duration.\n  Duration constrainLockDuration(Duration lockDuration) {\n    if (lockDuration < minLockDuration) return minLockDuration;\n    if (lockDuration > maxLockDuration) return maxLockDuration;"
        },
        {
          "name": "segments",
          "type": "final",
          "doc": "Normalizes a path by removing redundant separators and ensuring constraints\n  ///\n  /// Returns a normalized path string.\n  String normalizePath(String path) {\n    // Handle empty paths\n    if (path.isEmpty) return '';\n\n    // Split into segments and filter out empty ones (that come from consecutive separators)"
        },
        {
          "name": "normalized",
          "type": "final",
          "doc": "Extracts the parent path from a given path.\n  ///\n  /// Returns the parent path, or an empty string if the path has no parent.\n  String getParentPath(String path) {"
        },
        {
          "name": "lastSeparatorIndex",
          "type": "final",
          "doc": ""
        },
        {
          "name": "normalized",
          "type": "final",
          "doc": "Extracts the last segment (name) from a path.\n  ///\n  /// Returns the name component, or the full path if there are no separators.\n  String getNameFromPath(String path) {"
        },
        {
          "name": "lastSeparatorIndex",
          "type": "final",
          "doc": ""
        },
        {
          "name": "normalized",
          "type": "return",
          "doc": ""
        },
        {
          "name": "normalizedParent",
          "type": "final",
          "doc": "Checks if one path is a parent of another path.\n  ///\n  /// Returns true if parentPath is a parent of childPath.\n  bool isParentPath(String parentPath, String childPath) {"
        },
        {
          "name": "normalizedChild",
          "type": "final",
          "doc": ""
        },
        {
          "name": "true",
          "type": "return",
          "doc": ""
        },
        {
          "name": "true",
          "type": "return",
          "doc": "Validates an entity name based on configuration constraints.\n  ///\n  /// Returns true if the name:\n  /// - Is not empty\n  /// - Does not contain path separators\n  /// - Does not contain invalid characters\n  /// - Does not exceed maxPathSegment length\n  bool isValidEntityName(String name) {\n    if (name.isEmpty) return false;\n    if (name.length > maxPathSegment) return false;\n    if (name.contains(pathSeparator)) return false;\n    if (RegExp(invalidPathChars).hasMatch(name)) return false;"
        },
        {
          "name": "false",
          "type": "return",
          "doc": "Validates configuration values to ensure they are reasonable and consistent.\n  ///\n  /// Returns true if the configuration is valid.\n  bool validate() {\n    if (maxPathLength <= 0) return false;\n    if (maxPathSegment <= 0) return false;\n    if (maxHierarchyDepth <= 0) return false;\n    if (maxHistorySize < 0) return false;\n    if (defaultHistorySize < 0 || defaultHistorySize > maxHistorySize) {"
        },
        {
          "name": "false",
          "type": "return",
          "doc": ""
        },
        {
          "name": "true",
          "type": "return",
          "doc": ""
        },
        {
          "name": "differences",
          "type": "final",
          "doc": "Compares this configuration with another to identify differences.\n  ///\n  /// Returns a Map with property names as keys and a sub-map with 'this' and 'other' values\n  /// for each property that differs. Returns an empty map if the configurations are identical.\n  Map<String, Map<String, Object>> compareWith(EntityConfig other) {"
        },
        {
          "name": "differences",
          "type": "return",
          "doc": ""
        },
        {
          "name": "true",
          "type": "return",
          "doc": "Checks if this configuration is compatible with another configuration.\n  ///\n  /// A configuration is considered compatible when:\n  /// 1. Its path limits are equal to or greater than the other configuration\n  /// 2. It uses the same path separator character\n  /// 3. Its lock duration constraints can accommodate the other's default lock duration\n  ///\n  /// Returns true if this configuration is compatible with the other configuration.\n  bool isCompatibleWith(EntityConfig other) {\n    // Path compatibility\n    if (maxPathLength < other.maxPathLength) return false;\n    if (maxPathSegment < other.maxPathSegment) return false;\n    if (maxHierarchyDepth < other.maxHierarchyDepth) return false;\n    if (pathSeparator != other.pathSeparator) return false;\n\n    // Lock duration compatibility\n    if (other.defaultLockTimeout < minLockDuration) return false;\n    if (other.defaultLockTimeout > maxLockDuration) return false;\n\n    // Compatible with associated defaults\n    if (maxHistorySize < other.defaultHistorySize) return false;"
        },
        {
          "name": "pattern1",
          "type": "return",
          "doc": "Creates a merged configuration using the most permissive values from both configurations\n  ///\n  /// This is useful when you need to ensure compatibility between two environments\n  ///\n  /// Returns a new EntityConfig that will be compatible with both source configurations\n  EntityConfig mergeWith(EntityConfig other) {\n    return EntityConfig(\n      // Take the larger value for limits\n      maxPathLength: math.max(maxPathLength, other.maxPathLength),\n      maxPathSegment: math.max(maxPathSegment, other.maxPathSegment),\n      maxHierarchyDepth: math.max(maxHierarchyDepth, other.maxHierarchyDepth),\n      maxHistorySize: math.max(maxHistorySize, other.maxHistorySize),\n      defaultHistorySize: math.min(\n        math.max(defaultHistorySize, other.defaultHistorySize),\n        math.max(maxHistorySize, other.maxHistorySize),\n      ),\n\n      // Take the wider ranges for durations\n      defaultLockTimeout: Duration(\n        milliseconds:\n            (defaultLockTimeout.inMilliseconds +\n                other.defaultLockTimeout.inMilliseconds) ~/\n            2,\n      ),\n      lockExtensionPeriod: Duration(\n        milliseconds: math.max(\n          lockExtensionPeriod.inMilliseconds,\n          other.lockExtensionPeriod.inMilliseconds,\n        ),\n      ),\n      minLockDuration: Duration(\n        milliseconds: math.min(\n          minLockDuration.inMilliseconds,\n          other.minLockDuration.inMilliseconds,\n        ),\n      ),\n      maxLockDuration: Duration(\n        milliseconds: math.max(\n          maxLockDuration.inMilliseconds,\n          other.maxLockDuration.inMilliseconds,\n        ),\n      ),\n\n      // Preserve path separator from this config (they should be the same for compatibility)\n      pathSeparator: pathSeparator,\n\n      // Use most permissive regex pattern for invalid chars (if they differ)\n      invalidPathChars:\n          invalidPathChars == other.invalidPathChars\n              ? invalidPathChars\n              : _mergeInvalidCharsPatterns(\n                invalidPathChars,\n                other.invalidPathChars,\n              ),\n\n      // Use newest schema version\n      defaultVersion:\n          _compareVersions(defaultVersion, other.defaultVersion) >= 0\n              ? defaultVersion\n              : other.defaultVersion,\n\n      // Keep other settings from this config\n      defaultIsPublic: defaultIsPublic,\n      defaultPriority: defaultPriority,\n      defaultStage: defaultStage,\n    );\n  }\n\n  /// Helper method to merge two regex patterns for invalid characters,\n  /// creating a more permissive pattern that allows characters valid in either pattern.\n  static String _mergeInvalidCharsPatterns(String pattern1, String pattern2) {\n    // This is a simplified implementation - in a real system you might want\n    // a more sophisticated regex manipulation approach\n    try {\n      if (pattern1 == pattern2) return pattern1;\n\n      // Simple approach: just use the more restrictive pattern\n      // A more complete approach would parse and merge the character sets\n      if (pattern1.length > pattern2.length) return pattern2;"
        },
        {
          "name": "v1Parts",
          "type": "final",
          "doc": "Helper method to compare semantic version strings.\n  /// Returns positive if v1 > v2, negative if v1 < v2, 0 if equal.\n  static int _compareVersions(String v1, String v2) {\n    try {"
        },
        {
          "name": "v2Parts",
          "type": "final",
          "doc": ""
        },
        {
          "name": "diff",
          "type": "final",
          "doc": ""
        },
        {
          "name": "version",
          "type": "final",
          "doc": "Checks if this configuration version is compatible with another version.\n  ///\n  /// [otherVersion] - Version string to check compatibility with (e.g., \"1.2.3\")\n  /// [thisVersion] - Optional version to check, defaults to this config's version\n  ///\n  /// Returns true if versions are compatible.\n  bool isVersionCompatible(String otherVersion, [String? thisVersion]) {"
        },
        {
          "name": "vParts",
          "type": "final",
          "doc": ""
        },
        {
          "name": "otherParts",
          "type": "final",
          "doc": ""
        },
        {
          "name": "false",
          "type": "return",
          "doc": ""
        },
        {
          "name": "true",
          "type": "return",
          "doc": ""
        },
        {
          "name": "version",
          "type": "return",
          "doc": ""
        },
        {
          "name": "version",
          "type": "final",
          "doc": "Creates a new version string following semantic versioning.\n  ///\n  /// [increment] - Which part to increment: \"major\", \"minor\", or \"patch\"\n  /// [baseVersion] - Optional base version, defaults to this config's version\n  String incrementVersion(String increment, [String? baseVersion]) {"
        },
        {
          "name": "parts",
          "type": "final",
          "doc": ""
        },
        {
          "name": "newVersion",
          "type": "final",
          "doc": "Creates a new config with the version number incremented.\n  ///\n  /// This creates a new configuration with an updated version while\n  /// preserving all other settings.\n  ///\n  /// [increment] - Which part to increment: \"major\", \"minor\", or \"patch\"\n  ///\n  /// Returns a new EntityConfig with the updated version.\n  EntityConfig withIncrementedVersion(String increment) {"
        }
      ]
    },
    "DataManagerException": {
      "file": "lib/src/domain/core/exceptions.dart",
      "methods": [
        {
          "name": "DataManagerException",
          "params": "{\n    required this.message,\n    this.details,\n    this.context,\n  });\n\n  @override\n  String toString(",
          "doc": ""
        }
      ],
      "properties": [
        {
          "name": "message",
          "type": "String",
          "doc": ""
        },
        {
          "name": "buffer",
          "type": "final",
          "doc": ""
        }
      ]
    },
    "ValidationException": {
      "file": "lib/src/domain/core/exceptions.dart",
      "methods": [],
      "properties": [
        {
          "name": "field",
          "type": "String",
          "doc": ""
        },
        {
          "name": "invalidValue",
          "type": "dynamic",
          "doc": ""
        }
      ]
    },
    "FieldValidationException": {
      "file": "lib/src/domain/core/exceptions.dart",
      "methods": [],
      "properties": []
    },
    "PathValidationException": {
      "file": "lib/src/domain/core/exceptions.dart",
      "methods": [],
      "properties": []
    },
    "HierarchyValidationException": {
      "file": "lib/src/domain/core/exceptions.dart",
      "methods": [],
      "properties": [
        {
          "name": "depth",
          "type": "int",
          "doc": ""
        },
        {
          "name": "path",
          "type": "List<String>",
          "doc": ""
        }
      ]
    },
    "HierarchyException": {
      "file": "lib/src/domain/core/exceptions.dart",
      "methods": [],
      "properties": []
    },
    "VersionConflictException": {
      "file": "lib/src/domain/core/exceptions.dart",
      "methods": [],
      "properties": [
        {
          "name": "currentVersion",
          "type": "String",
          "doc": ""
        },
        {
          "name": "conflictingVersion",
          "type": "String",
          "doc": ""
        }
      ]
    },
    "LockException": {
      "file": "lib/src/domain/core/exceptions.dart",
      "methods": [],
      "properties": []
    },
    "AccessException": {
      "file": "lib/src/domain/core/exceptions.dart",
      "methods": [],
      "properties": [
        {
          "name": "resource",
          "type": "String",
          "doc": ""
        },
        {
          "name": "action",
          "type": "String",
          "doc": ""
        }
      ]
    },
    "IntegrityException": {
      "file": "lib/src/domain/core/exceptions.dart",
      "methods": [],
      "properties": [
        {
          "name": "entity",
          "type": "String",
          "doc": ""
        },
        {
          "name": "operation",
          "type": "String",
          "doc": ""
        }
      ]
    },
    "OperationException": {
      "file": "lib/src/domain/core/exceptions.dart",
      "methods": [],
      "properties": [
        {
          "name": "operation",
          "type": "String",
          "doc": ""
        },
        {
          "name": "params",
          "type": "Map<String, dynamic>",
          "doc": ""
        }
      ]
    },
    "AIProcessingException": {
      "file": "lib/src/domain/core/exceptions.dart",
      "methods": [],
      "properties": [
        {
          "name": "modelId",
          "type": "String",
          "doc": ""
        },
        {
          "name": "operation",
          "type": "String",
          "doc": ""
        }
      ]
    }
  },
  "interfaces": {
    "EntityLimits": {
      "file": "lib/src/domain/entities/base_entity.dart",
      "methods": []
    },
    "EventDefaults": {
      "file": "lib/src/domain/events/domain_event.dart",
      "methods": []
    },
    "EventSchemaConfig": {
      "file": "lib/src/domain/events/domain_event.dart",
      "methods": []
    },
    "EntityDefaults": {
      "file": "lib/src/domain/core/core_entity.dart",
      "methods": []
    },
    "EntityConfigDefaults": {
      "file": "lib/src/domain/core/entity_config.dart",
      "methods": []
    },
    "DataManagerException": {
      "file": "lib/src/domain/core/exceptions.dart",
      "methods": [
        {
          "name": "DataManagerException",
          "params": "{\n    required this.message,\n    this.details,\n    this.context,\n  }",
          "doc": ""
        },
        {
          "name": "toString",
          "params": "",
          "doc": ""
        },
        {
          "name": "if",
          "params": "details != null) buffer.write('\\nDetails: $details'",
          "doc": ""
        }
      ]
    }
  },
  "enums": {
    "EventType": {
      "file": "lib/src/domain/events/domain_event.dart",
      "values": [
        "// Entity lifecycle\n  created",
        "updated",
        "deleted",
        "// Status management\n  locked",
        "unlocked",
        "statusChanged",
        "// Workflow\n  workflowChanged",
        "workflowTransitioned",
        "workflowStepCompleted",
        "workflowStepRejected",
        "// Relationships\n  relationshipChanged",
        "relationshipAdded",
        "relationshipRemoved",
        "// Hierarchy\n  hierarchyChanged",
        "hierarchyParentChanged",
        "hierarchyChildAdded",
        "hierarchyChildRemoved",
        "// Metadata\n  metadataChanged",
        "tagged",
        "untagged",
        "// Access control\n  accessGranted",
        "accessRevoked",
        "// Synchronization\n  syncStarted",
        "syncCompleted",
        "// Versioning\n  versionCreated",
        "versionMerged"
      ]
    },
    "OperationType": {
      "file": "lib/src/domain/value_objects/enum_objects.dart",
      "values": [
        "create",
        "read",
        "update",
        "delete",
        "validate",
        "repair",
        "sync"
      ]
    },
    "SortOrder": {
      "file": "lib/src/domain/value_objects/enum_objects.dart",
      "values": [
        "ascending",
        "descending"
      ]
    },
    "SyncMode": {
      "file": "lib/src/domain/value_objects/enum_objects.dart",
      "values": [
        "full",
        "incremental",
        "metadataOnly"
      ]
    },
    "ValidationLevel": {
      "file": "lib/src/domain/value_objects/enum_objects.dart",
      "values": [
        "strict",
        "lenient",
        "none"
      ]
    },
    "HierarchyDirection": {
      "file": "lib/src/domain/value_objects/enum_objects.dart",
      "values": [
        "children",
        "ancestors",
        "descendants"
      ]
    },
    "EntityStatus": {
      "file": "lib/src/domain/value_objects/enum_objects.dart",
      "values": [
        "active",
        "inactive",
        "archived",
        "deleted"
      ]
    },
    "EntityPriority": {
      "file": "lib/src/domain/value_objects/enum_objects.dart",
      "values": [
        "/// Low priority entities.\n  low('low')",
        "/// Medium priority entities (default).\n  medium('medium')",
        "/// High priority entities.\n  high('high')",
        "/// Critical priority entities requiring immediate attention.\n  critical('critical');\n\n  /// Creates a new entity priority with the given string representation.\n  const EntityPriority(this.value);\n\n  /// The string representation of this priority level.\n  final String value;\n\n  /// Converts a string to the corresponding EntityPriority.\n  ///\n  /// Returns [EntityPriority.medium] if the string doesn't match any priority.\n  static EntityPriority fromString(String value) {\n    return EntityPriority.values.firstWhere(\n      (priority) => priority.value == value.toLowerCase()",
        "orElse: () => EntityPriority.medium",
        ");"
      ]
    },
    "EntityStage": {
      "file": "lib/src/domain/value_objects/enum_objects.dart",
      "values": [
        "/// Initial draft stage.\n  draft('draft')",
        "/// Review stage where entity is being evaluated.\n  review('review')",
        "/// Approved stage ready for publication or deployment.\n  approved('approved')",
        "/// Published stage where entity is publicly available.\n  published('published')",
        "/// Archived stage for inactive entities.\n  archived('archived');\n\n  /// Creates a new entity stage with the given string representation.\n  const EntityStage(this.value);\n\n  /// The string representation of this workflow stage.\n  final String value;\n\n  /// Converts a string to the corresponding EntityStage.\n  ///\n  /// Returns [EntityStage.draft] if the string doesn't match any stage.\n  static EntityStage fromString(String value) {\n    return EntityStage.values.firstWhere(\n      (stage) => stage.value == value.toLowerCase()",
        "orElse: () => EntityStage.draft",
        ");"
      ]
    },
    "EquipmentType": {
      "file": "lib/src/domain/value_objects/enum_objects.dart",
      "values": [
        "pcs",
        "bess",
        "array",
        "stack",
        "bp",
        "cell"
      ]
    },
    "UserRole": {
      "file": "lib/src/domain/value_objects/enum_objects.dart",
      "values": [
        "admin",
        "manager",
        "technician",
        "viewer"
      ]
    },
    "LockStatus": {
      "file": "lib/src/domain/value_objects/enum_objects.dart",
      "values": [
        "unlocked",
        "lockedByCurrentUser",
        "lockedByOtherUser",
        "expired"
      ]
    }
  },
  "typedefs": {
    "OwnerEntityModel": {
      "file": "lib/src/domain/entities/entity_types.dart",
      "type": "BaseEntityModel<OwnerData>"
    },
    "SiteEntityModel": {
      "file": "lib/src/domain/entities/entity_types.dart",
      "type": "BaseEntityModel<SiteData>"
    },
    "EquipmentEntityModel": {
      "file": "lib/src/domain/entities/entity_types.dart",
      "type": "BaseEntityModel<EquipmentData>"
    },
    "VendorEntityModel": {
      "file": "lib/src/domain/entities/entity_types.dart",
      "type": "BaseEntityModel<VendorData>"
    },
    "PersonnelEntityModel": {
      "file": "lib/src/domain/entities/entity_types.dart",
      "type": "BaseEntityModel<PersonnelData>"
    },
    "EntityVersionVector": {
      "file": "lib/src/domain/entities/base_entity.dart",
      "type": "Map<String, int>"
    },
    "EntityEventMeta": {
      "file": "lib/src/domain/entities/base_entity.dart",
      "type": "Map<String, Object>"
    },
    "EntitySearchIndex": {
      "file": "lib/src/domain/entities/base_entity.dart",
      "type": "Map<String, Object>"
    }
  },
  "functions": {
    "EntityCreationConfig": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "params": "{\n    required this.name,\n    required this.user,\n    required this.data,\n    this.description,\n    this.parentPath,\n    this.parentId,\n    this.ancestors,\n    this.meta,\n    this.tags,\n    this.labels,\n    this.priority,\n    this.stage,\n    this.expiryDate,\n    this.isPublic,\n  });\n}\n\n/// Configuration object for cloning existing entities.\n/// Contains the source entity and optional overrides for the clone.\nclass EntityCloningConfig<T extends Object> {\n  /// Source entity to clone\n  final BaseEntityModel<T> source;\n\n  /// User performing the cloning operation\n  final AuthUser user;\n\n  /// New name for the cloned entity (defaults to source name + \" (Copy)\")\n  final String? newName;\n\n  /// New path for the cloned entity\n  final String? newPath;\n\n  /// Custom metadata overrides for the clone\n  final Map<String, Object>? newMeta;\n\n  /// Label overrides for the clone\n  final Map<String, String>? newLabels;\n\n  /// Tag overrides for the clone\n  final List<String>? newTags;\n\n  EntityCloningConfig({\n    required this.source,\n    required this.user,\n    this.newName,\n    this.newPath,\n    this.newMeta,\n    this.newLabels,\n    this.newTags,\n  });\n}\n\n/// A fluent builder for creating entities\n///\n/// Provides method chaining for a cleaner API when creating complex entities\n/// with many optional parameters\n///\n/// Example:\n/// ```dart\n/// final site = EntityCreationBuilder<SiteModel>()\n///   .withName('Main Office')\n///   .withUser(currentUser)\n///   .withData(siteModel)\n///   .withParentId(organizationId)\n///   .withTags(['headquarters', 'office'])\n///   .build();\n/// ```\nclass EntityCreationBuilder<T extends Object> {\n  // Required fields\n  String? _name;\n  AuthUser? _user;\n  T? _data;\n\n  // Optional fields\n  String? _description;\n  String? _parentPath;\n  EntityId? _parentId;\n  List<EntityId>? _ancestors;\n  Map<String, Object>? _meta;\n  List<String>? _tags;\n  Map<String, String>? _labels;\n  EntityPriority? _priority;\n  EntityStage? _stage;\n  DateTime? _expiryDate;\n  bool? _isPublic;\n\n  // Required field methods\n  /// Sets the name for the entity\n  EntityCreationBuilder<T> withName(String name",
      "doc": "Configuration data for new entity creation\n///\n/// Contains core entity information, hierarchy data, and classification parameters\nclass EntityCreationConfig<T extends Object> {\n  // Core info\n  /// User-provided name for the entity\n  final String name;\n\n  /// User creating the entity\n  final AuthUser user;\n\n  /// Type-specific payload data\n  final T data;\n\n  /// Optional description of the entity\n  final String? description;\n\n  // Tree structure\n  /// Path in the entity hierarchy\n  final String? parentPath;\n\n  /// Direct parent entity ID\n  final EntityId? parentId;\n\n  /// List of ancestor entity IDs\n  final List<EntityId>? ancestors;\n\n  // Metadata & Classification\n  /// Custom metadata key-value pairs\n  final Map<String, Object>? meta;\n\n  /// Searchable tags\n  final List<String>? tags;\n\n  /// Categorization labels\n  final Map<String, String>? labels;\n\n  /// Entity importance level\n  final EntityPriority? priority;\n\n  /// Current workflow stage\n  final EntityStage? stage;\n\n  /// Optional date when entity expires\n  final DateTime? expiryDate;\n\n  /// Whether entity is publicly accessible\n  final bool? isPublic;"
    },
    "withUser": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "params": "AuthUser user",
      "doc": "Sets the user performing the clone operation"
    },
    "withData": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "params": "T data",
      "doc": "Sets the type-specific payload data"
    },
    "withDescription": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "params": "String description",
      "doc": "Sets the description for the entity"
    },
    "withParentPath": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "params": "String parentPath",
      "doc": "Sets the parent path in the entity hierarchy"
    },
    "withParentId": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "params": "EntityId parentId",
      "doc": "Sets the direct parent entity ID"
    },
    "withAncestors": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "params": "List<EntityId> ancestors",
      "doc": "Sets the list of ancestor entity IDs"
    },
    "withMeta": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "params": "Map<String, Object> newMeta",
      "doc": "Sets custom metadata for the cloned entity"
    },
    "withTags": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "params": "List<String> newTags",
      "doc": "Sets tags for the cloned entity"
    },
    "withLabels": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "params": "Map<String, String> newLabels",
      "doc": "Sets labels for the cloned entity"
    },
    "withPriority": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "params": "EntityPriority priority",
      "doc": "Sets the entity importance level"
    },
    "withStage": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "params": "EntityStage stage",
      "doc": "Sets the workflow stage"
    },
    "withExpiryDate": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "params": "DateTime expiryDate",
      "doc": "Sets the expiry date for the entity"
    },
    "isPublic": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "params": "bool isPublic",
      "doc": "Sets whether the entity is publicly accessible"
    },
    "build": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "params": "",
      "doc": ""
    },
    "if": {
      "file": "lib/src/domain/core/entity_config.dart",
      "params": "parts.length != 3",
      "doc": ""
    },
    "ArgumentError": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "params": "'Invalid type: ${T.toString()}');\n    }\n\n    final now = DateTime.now();\n    final userAction = UserAction.fromAuthUser(config.user);\n    final id = EntityId(const Uuid().v4());\n\n    // Create core entity\n    final core = CoreEntity<T>(\n      id: id,\n      name: config.name,\n      description: config.description,\n      createdAt: now,\n      updatedAt: now,\n      owner: userAction,\n      creator: userAction,\n      modifier: userAction,\n      data: config.data,\n      meta: config.meta ?? {},\n    );\n\n    // Create entity with component structure\n    var entity = BaseEntityModel<T>(\n      core: core,\n      hierarchy: EntityHierarchy(\n        treePath: config.parentPath,\n        parentId: config.parentId,\n        ancestors: config.ancestors ?? [],\n        isHierarchyRoot: config.parentId == null,\n        isHierarchyLeaf: true,\n      ),\n      security: EntitySecurity(\n        modHistory: [userAction],\n        accessLog: [userAction],\n        isPublic: config.isPublic ?? EntityDefaults.isPublic,\n      ),\n      classification: EntityClassification(\n        tags: config.tags ?? [],\n        labels: config.labels ?? {},\n        priority: config.priority ?? EntityDefaults.priority,\n        stage: config.stage ?? EntityDefaults.stage,\n        expiryDate: config.expiryDate,\n      ),\n      versioning: const EntityVersioning(),\n    );\n\n    // Use extension methods for validation and path processing\n    if (!entity.isValidPath(entity.hierarchy.treePath)",
      "doc": ""
    },
    "withName": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "params": "String newName",
      "doc": "Sets the name for the cloned entity"
    },
    "withPath": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "params": "String newPath",
      "doc": "Sets the path for the cloned entity"
    },
    "PathValidationException": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "params": "message: 'Invalid path format',\n        path: entity.hierarchy.treePath,\n      );\n    }\n\n    if (entity.hasCircularReference()",
      "doc": ""
    },
    "HierarchyValidationException": {
      "file": "lib/src/domain/entities/entity_factory.dart",
      "params": "message: 'Circular reference detected',\n        field: 'hierarchy',\n        depth: entity.hierarchy.ancestors.length,\n        path: entity.hierarchy.ancestors.map((a",
      "doc": ""
    },
    "applyEvent": {
      "file": "lib/src/domain/entities/entity_types.dart",
      "params": "DomainEventModel event",
      "doc": "Domain-specific data models for business entities\n@freezed\nsealed class OwnerData with _$OwnerData {\n  const OwnerData._(); // Private constructor for methods\n\n  /// Entity owner data model representing an organization or individual\n  ///\n  /// Stores contact information and site references\n  const factory OwnerData({\n    // Core info\n    required ContactInfo contact,\n    @Default([]) List<EntityId> siteIds,\n\n    // Metadata\n    @Default({}) Map<String, Object> meta,\n    Map<String, Object>? customData,\n  }) = _OwnerData;\n\n  factory OwnerData.fromJson(Map<String, Object> json) =>\n      _$OwnerDataFromJson(json);\n\n  // Computed properties\n  /// Whether this owner has associated sites\n  bool get hasSites => siteIds.isNotEmpty;\n\n  /// Whether owner has multiple sites\n  bool get hasMultipleSites => siteIds.length > 1;\n\n  /// Whether valid contact information exists\n  bool get hasValidContact => contact.email != null || contact.phone != null;\n\n  /// Human-readable name for display\n  String get displayName => contact.displayName;\n\n  /// Applies domain event and returns updated state\n  ///\n  /// Processes event data to create new entity state without mutation"
    },
    "switch": {
      "file": "lib/src/domain/core/entity_config.dart",
      "params": "increment.toLowerCase()",
      "doc": ""
    },
    "EntityHierarchy": {
      "file": "lib/src/domain/entities/base_entity.dart",
      "params": "treePath: '/$entityId',\n      treeDepth: 0,\n      ancestors: const [],\n      parentId: null,\n      childIds: const [],\n      isHierarchyRoot: true,\n      isHierarchyLeaf: true,\n      hierarchyMeta: {'created': now.toIso8601String(), 'pathType': 'root'},\n    );\n  }\n}\n\n/// Extension methods for EntityHierarchy operations\nextension EntityHierarchyOperations on EntityHierarchy {\n  /// Adds a child entity ID, updating leaf status and metadata\n  EntityHierarchy addChild(EntityId childId",
      "doc": "Type aliases for improved code readability\ntypedef EntityVersionVector = Map<String, int>;\ntypedef EntityEventMeta = Map<String, Object>;\ntypedef EntitySearchIndex = Map<String, Object>;\n\n/// Constants defining entity system boundaries and limitations\nabstract class EntityLimits {\n  /// Maximum length of a path in characters\n  static const int pathMaxLength = 1024;\n\n  /// Maximum length of a path segment in characters\n  static const int pathMaxSegment = 255;\n\n  /// Maximum allowed depth in entity hierarchy\n  static const int hierarchyDepthMax = 10;\n\n  /// Maximum number of history entries to retain\n  static const int historyMax = 50;\n\n  /// Default number of history entries to retain\n  static const int historyDefault = 50;\n}\n\n/// Represents hierarchy information for an entity including tree structure and relationships\n@freezed\nsealed class EntityHierarchy with _$EntityHierarchy {\n  const EntityHierarchy._(); // This private constructor already exists\n\n  /// Creates a new EntityHierarchy instance\n  const factory EntityHierarchy({\n    /// Full path in the entity tree\n    ///\n    /// Format: '/parent_id/grandparent_id/entity_id'\n    /// Paths use forward slashes as separators and start with a leading slash\n    /// Path segments are entity IDs in reverse ancestry order\n    String? treePath,\n\n    /// Depth level in the hierarchy (0 = root)\n    @Default(0) int treeDepth,\n\n    /// List of ancestor entity IDs in order from root to parent\n    @Default(<EntityId>[]) List<EntityId> ancestors,\n\n    /// Direct parent entity ID\n    EntityId? parentId,\n\n    /// List of direct child entity IDs\n    @Default(<EntityId>[]) List<EntityId> childIds,\n\n    /// Indicates if this entity is a root node in a hierarchy\n    @Default(true) bool isHierarchyRoot,\n\n    /// Indicates if this entity is a leaf node (has no children)\n    @Default(true) bool isHierarchyLeaf,\n\n    /// Additional hierarchy-related metadata\n    @Default({}) Map<String, Object> hierarchyMeta,\n  }) = _EntityHierarchy;\n\n  /// Creates a new root EntityHierarchy instance\n  factory EntityHierarchy.root(String entityId) {\n    final now = DateTime.now();"
    },
    "copyWith": {
      "file": "lib/src/domain/core/core_entity.dart",
      "params": "meta: updatedMeta);\n  }\n\n  /// Gets typed value from metadata safely\n  Object? _getMetadataTyped<R>(String key",
      "doc": ""
    },
    "isValidPath": {
      "file": "lib/src/domain/core/entity_config.dart",
      "params": "String path",
      "doc": "Validates if a path string conforms to the configuration constraints\n  ///\n  /// Returns true if the path is valid according to all path constraints"
    },
    "splitPath": {
      "file": "lib/src/domain/entities/base_entity.dart",
      "params": "String? path, {EntityConfig? config}",
      "doc": ""
    },
    "sanitizePath": {
      "file": "lib/src/domain/core/entity_config.dart",
      "params": "segments.join(pathSeparator));\n  }\n\n  /// Extracts the parent path from a given path.\n  ///\n  /// Returns the parent path, or an empty string if the path has no parent.\n  String getParentPath(String path",
      "doc": ""
    },
    "isAncestorOf": {
      "file": "lib/src/domain/entities/base_entity.dart",
      "params": "BaseEntityModel<T> other",
      "doc": "Returns the absolute path for this entity (including its own ID)\n  String get absolutePath => sanitizePath(\n    '${hierarchy.treePath ?? ''}/${id.value}',\n    trailingSlash: false,\n  );\n\n  // Hierarchy navigation\n  List<String> get ancestorIds =>\n      hierarchy.ancestors.map((a) => a.value).toList();\n  String get fullPath => hierarchy.treePath ?? id.value;"
    },
    "isDescendantOf": {
      "file": "lib/src/domain/entities/base_entity.dart",
      "params": "BaseEntityModel<T> other",
      "doc": ""
    },
    "getDepthTo": {
      "file": "lib/src/domain/entities/base_entity.dart",
      "params": "BaseEntityModel<T> ancestor",
      "doc": ""
    },
    "updateHierarchy": {
      "file": "lib/src/domain/entities/base_entity.dart",
      "params": "{\n    required EntityId? newParentId,\n    String? newPath,\n    List<EntityId>? newAncestors,\n    bool validateDepth = true,\n  }",
      "doc": ""
    },
    "Exception": {
      "file": "lib/src/domain/entities/base_entity.dart",
      "params": "'Hierarchy depth exceeded');\n    }\n    final updatedPath = newPath ?? hierarchy.treePath ?? '';\n    final updatedMeta = {\n      ...hierarchy.hierarchyMeta,\n      'last_hierarchy_update': DateTime.now().toIso8601String(),\n      'parent_history': [\n        ...(hierarchy.hierarchyMeta['parent_history'] as List<String>? ?? []),\n        newParentId?.value ?? 'root',\n      ],\n    };\n    return copyWith(\n      hierarchy: hierarchy.copyWith(\n        parentId: newParentId,\n        treePath: updatedPath,\n        ancestors: ancestors,\n        treeDepth: ancestors.length,\n        isHierarchyRoot: newParentId == null,\n        isHierarchyLeaf: hierarchy.childIds.isEmpty,\n        hierarchyMeta: updatedMeta,\n      ),\n    );\n  }\n\n  Map<String, Object> buildHierarchyIndex(",
      "doc": ""
    },
    "BaseEntityModel": {
      "file": "lib/src/domain/entities/base_entity.dart",
      "params": "core: CoreEntity(\n        id: id,\n        name: name,\n        createdAt: now,\n        updatedAt: now,\n        owner: owner,\n        creator: owner,\n        modifier: owner,\n        data: data,\n      ),\n      hierarchy:\n          hierarchy ??\n          EntityHierarchy(\n            treePath: id.value,\n            isHierarchyRoot: true,\n            isHierarchyLeaf: true,\n            hierarchyMeta: {\n              'created': now.toIso8601String(),\n              'pathType': 'root',\n            },\n          ),\n      security: security ?? const EntitySecurity(),\n      classification: classification ?? const EntityClassification(),\n      versioning: versioning ?? const EntityVersioning(),\n    );\n  }\n\n  /// Adds a child to a parent and updates both entities' hierarchy fields for consistency.\n  ///\n  /// Returns a Dart 3 record (updatedParent, updatedChild).\n  static (BaseEntityModel<T>, BaseEntityModel<T>) addChildAndUpdateChild<\n    T extends Object\n  >(BaseEntityModel<T> parent, BaseEntityModel<T> child",
      "doc": ""
    },
    "return": {
      "file": "lib/src/domain/core/core_entity.dart",
      "params": "value != null) ? value as DateTime : defaultValue;\n  }\n\n  /// Gets typed list from metadata\n  /// [key] - The metadata key containing a List to be converted\n  /// Returns a strongly-typed list or null if conversion fails\n  List<R>? getListAs<R>(String key",
      "doc": "Gets DateTime value from metadata\n  /// [key] - The metadata key to retrieve\n  /// [defaultValue] - Value to return if the key doesn't exist or can't be converted\n  /// Returns typed DateTime value or the default value\n  DateTime? getDateTime(String key, {DateTime? defaultValue}) {\n    final value = _getValueTyped<DateTime>(key);"
    },
    "while": {
      "file": "lib/src/domain/entities/base_entity.dart",
      "params": "queue.length > maxSize",
      "doc": ""
    },
    "DomainEventModel": {
      "file": "lib/src/domain/events/domain_event.dart",
      "params": "id: id,\n      entityId: entityId,\n      entityType: entityType,\n      eventType: EventType.hierarchyChanged.name,\n      timestamp: action.timestamp,\n      initiator: action,\n      changes: {\n        'oldParentId': oldParentId?.value ?? '',\n        'newParentId': newParentId?.value ?? '',\n      },\n    );\n  }\n\n  /// Schema validation\n  bool hasValidSchema(",
      "doc": ""
    },
    "isBackwardsCompatible": {
      "file": "lib/src/domain/events/domain_event.dart",
      "params": "",
      "doc": ""
    },
    "migrateSchema": {
      "file": "lib/src/domain/events/domain_event.dart",
      "params": "String targetVersion",
      "doc": "Domain event interface method for schema migration\n  /// Actual implementation is moved to application layer"
    },
    "UnimplementedError": {
      "file": "lib/src/domain/events/domain_event.dart",
      "params": "'Schema migration implementation should be provided by the application layer',\n    );\n  }\n\n  /// Schema version vector operations\n  bool hasVectorConflict(Map<String, int> otherVectors",
      "doc": ""
    },
    "incrementVector": {
      "file": "lib/src/domain/events/domain_event.dart",
      "params": "String node",
      "doc": ""
    },
    "for": {
      "file": "lib/src/domain/core/entity_config.dart",
      "params": "var i = 0; i < math.min(v1Parts.length, v2Parts.length); i++",
      "doc": "Helper method to compare semantic version strings.\n  /// Returns positive if v1 > v2, negative if v1 < v2, 0 if equal.\n  static int _compareVersions(String v1, String v2) {\n    try {\n      final v1Parts = v1.split('.').map(int.parse).toList();\n      final v2Parts = v2.split('.').map(int.parse).toList();"
    },
    "low": {
      "file": "lib/src/domain/value_objects/enum_objects.dart",
      "params": "'low'),\n\n  /// Medium priority entities (default).\n  medium('medium'),\n\n  /// High priority entities.\n  high('high'),\n\n  /// Critical priority entities requiring immediate attention.\n  critical('critical');\n\n  /// Creates a new entity priority with the given string representation.\n  const EntityPriority(this.value);\n\n  /// The string representation of this priority level.\n  final String value;\n\n  /// Converts a string to the corresponding EntityPriority.\n  ///\n  /// Returns [EntityPriority.medium] if the string doesn't match any priority.\n  static EntityPriority fromString(String value",
      "doc": "Defines priority levels for entities in the data manager.\nenum EntityPriority {\n  /// Low priority entities."
    },
    "draft": {
      "file": "lib/src/domain/value_objects/enum_objects.dart",
      "params": "'draft'),\n\n  /// Review stage where entity is being evaluated.\n  review('review'),\n\n  /// Approved stage ready for publication or deployment.\n  approved('approved'),\n\n  /// Published stage where entity is publicly available.\n  published('published'),\n\n  /// Archived stage for inactive entities.\n  archived('archived');\n\n  /// Creates a new entity stage with the given string representation.\n  const EntityStage(this.value);\n\n  /// The string representation of this workflow stage.\n  final String value;\n\n  /// Converts a string to the corresponding EntityStage.\n  ///\n  /// Returns [EntityStage.draft] if the string doesn't match any stage.\n  static EntityStage fromString(String value",
      "doc": "Defines workflow stages for entities in the data manager.\nenum EntityStage {\n  /// Initial draft stage."
    },
    "UserAction": {
      "file": "lib/src/domain/value_objects/user_action.dart",
      "params": "uid: 'system',\n      timestamp: DateTime.now(),\n      actionType: actionType,\n      description: description,\n      isAuthenticated: true,\n      isAuthorized: true,\n    );\n  }\n}\n\n/// Extension methods for UserAction\nextension UserActionX on UserAction {\n  /// Checks if the action is a system action\n  bool get isSystemAction => uid == 'system';\n\n  /// Checks if the action is an anonymous action\n  bool get isAnonymousAction => uid == 'anonymous';\n\n  /// Gets the action age\n  Duration get age => DateTime.now().difference(timestamp);\n\n  /// Checks if the action is recent (within last hour)\n  bool get isRecent => age.inHours < 1;\n\n  /// Creates a copy with audit trail information\n  UserAction withAuditInfo({\n    required String previousValue,\n    required String newValue,\n    required String reason,\n  }",
      "doc": ""
    },
    "isWithinTolerance": {
      "file": "lib/src/domain/value_objects/measurement_value_objects.dart",
      "params": "double target",
      "doc": ""
    },
    "overlaps": {
      "file": "lib/src/domain/value_objects/measurement_value_objects.dart",
      "params": "Range<T> other",
      "doc": ""
    },
    "contains": {
      "file": "lib/src/domain/value_objects/time_value_objects.dart",
      "params": "DateTime time",
      "doc": ""
    },
    "isActive": {
      "file": "lib/src/domain/value_objects/time_value_objects.dart",
      "params": "",
      "doc": ""
    },
    "isAvailable": {
      "file": "lib/src/domain/value_objects/time_value_objects.dart",
      "params": "DateTime time",
      "doc": ""
    },
    "ReferenceNumber": {
      "file": "lib/src/domain/value_objects/identity_value_objects.dart",
      "params": "prefix: parts[0],\n      sequence: int.parse(parts[1]),\n      suffix: parts.length > 2 ? parts[2] : null,\n    );\n  }\n\n  factory ReferenceNumber.fromJson(Map<String, Object?> json",
      "doc": ""
    },
    "TypedMetadata": {
      "file": "lib/src/domain/core/core_entity.dart",
      "params": "value);\n    }\n    return null;\n  }\n\n  /// Tries multiple keys in sequence until finding a non-null value\n  /// [keys] - List of keys to try in order\n  /// Returns the first matching value or null if no matches\n  Object? getFirstMatching<T>(List<String> keys",
      "doc": ""
    },
    "assert": {
      "file": "lib/src/domain/core/core_entity.dart",
      "params": "(",
      "doc": ""
    },
    "getInt": {
      "file": "lib/src/domain/core/core_entity.dart",
      "params": "String key, {int defaultValue = 0}",
      "doc": "Gets integer value from metadata\n  /// [key] - The metadata key to retrieve\n  /// [defaultValue] - Value to return if the key doesn't exist or can't be converted\n  /// Returns typed int value or the default value"
    },
    "getDouble": {
      "file": "lib/src/domain/core/core_entity.dart",
      "params": "String key, {double defaultValue = 0.0}",
      "doc": "Gets double value from metadata\n  /// [key] - The metadata key to retrieve\n  /// [defaultValue] - Value to return if the key doesn't exist or can't be converted\n  /// Returns typed double value or the default value"
    },
    "getBool": {
      "file": "lib/src/domain/core/core_entity.dart",
      "params": "String key, {bool defaultValue = false}",
      "doc": "Gets boolean value from metadata\n  /// [key] - The metadata key to retrieve\n  /// [defaultValue] - Value to return if the key doesn't exist or can't be converted\n  /// Returns typed boolean value or the default value"
    },
    "clearCacheEntry": {
      "file": "lib/src/domain/core/core_entity.dart",
      "params": "String key",
      "doc": "Clears a specific entry from the type conversion cache\n  /// [key] - The metadata key whose cached value should be removed"
    },
    "hasMetadata": {
      "file": "lib/src/domain/core/core_entity.dart",
      "params": "String key",
      "doc": "Unique identifier string from entity ID\n  String get uid => id.value;\n\n  /// Runtime type of entity data\n  String get type => data?.runtimeType.toString() ?? T.toString();\n\n  /// Type-safe metadata accessor\n  TypedMetadata get typedMeta => TypedMetadata(meta);\n\n  /// Gets typed value from metadata\n  /// [key] - The metadata key to retrieve\n  /// [R] - The target type to convert the value to\n  /// Returns the value converted to type R or null if conversion fails\n  Object? getMetadataAs<R>(String key) => getMetadata<R>(key);\n\n  /// Gets typed value from metadata\n  /// [key] - The metadata key to retrieve\n  /// [R] - The target type to convert the value to\n  /// Returns the value converted to type R or null if conversion fails\n  Object? getMetadata<R>(String key) => _getMetadataTyped<R>(key);\n\n  /// Gets raw value from metadata without type conversion\n  /// [key] - The metadata key to retrieve\n  /// Returns the raw Object value or null if key doesn't exist\n  Object? getMetadataValue(String key) => meta[key];\n\n  /// Checks if metadata contains a key\n  /// [key] - The metadata key to check\n  /// Returns true if the key exists in metadata, false otherwise"
    },
    "filterMetadata": {
      "file": "lib/src/domain/core/core_entity.dart",
      "params": "bool Function(String key, Object value) predicate,",
      "doc": "Gets typed metadata with default fallback\n  /// [key] - The metadata key to retrieve\n  /// [defaultValue] - Value to return if the key doesn't exist or can't be converted\n  Object? getMetadataOrDefault<R>(String key, R defaultValue) {\n    return _getMetadataTyped<R>(key) ?? defaultValue;\n  }\n\n  /// Returns filtered metadata based on predicate\n  /// [predicate] - Function that tests each key and value"
    },
    "updateMetadata": {
      "file": "lib/src/domain/core/core_entity.dart",
      "params": "Map<String, Object> updates, {\n    List<String>? removeKeys,\n  }",
      "doc": "Creates new instance with updated metadata\n  /// [updates] - Map of key-value pairs to add or update in metadata\n  /// [removeKeys] - Optional list of keys to remove from metadata"
    },
    "EntityConfig": {
      "file": "lib/src/domain/core/entity_config.dart",
      "params": "// Take the larger value for limits\n      maxPathLength: math.max(maxPathLength, other.maxPathLength),\n      maxPathSegment: math.max(maxPathSegment, other.maxPathSegment),\n      maxHierarchyDepth: math.max(maxHierarchyDepth, other.maxHierarchyDepth),\n      maxHistorySize: math.max(maxHistorySize, other.maxHistorySize),\n      defaultHistorySize: math.min(\n        math.max(defaultHistorySize, other.defaultHistorySize),\n        math.max(maxHistorySize, other.maxHistorySize),\n      ),\n\n      // Take the wider ranges for durations\n      defaultLockTimeout: Duration(\n        milliseconds:\n            (defaultLockTimeout.inMilliseconds +\n                other.defaultLockTimeout.inMilliseconds) ~/\n            2,\n      ),\n      lockExtensionPeriod: Duration(\n        milliseconds: math.max(\n          lockExtensionPeriod.inMilliseconds,\n          other.lockExtensionPeriod.inMilliseconds,\n        ),\n      ),\n      minLockDuration: Duration(\n        milliseconds: math.min(\n          minLockDuration.inMilliseconds,\n          other.minLockDuration.inMilliseconds,\n        ),\n      ),\n      maxLockDuration: Duration(\n        milliseconds: math.max(\n          maxLockDuration.inMilliseconds,\n          other.maxLockDuration.inMilliseconds,\n        ),\n      ),\n\n      // Preserve path separator from this config (they should be the same for compatibility)\n      pathSeparator: pathSeparator,\n\n      // Use most permissive regex pattern for invalid chars (if they differ)\n      invalidPathChars:\n          invalidPathChars == other.invalidPathChars\n              ? invalidPathChars\n              : _mergeInvalidCharsPatterns(\n                invalidPathChars,\n                other.invalidPathChars,\n              ),\n\n      // Use newest schema version\n      defaultVersion:\n          _compareVersions(defaultVersion, other.defaultVersion) >= 0\n              ? defaultVersion\n              : other.defaultVersion,\n\n      // Keep other settings from this config\n      defaultIsPublic: defaultIsPublic,\n      defaultPriority: defaultPriority,\n      defaultStage: defaultStage,\n    );\n  }\n\n  /// Helper method to merge two regex patterns for invalid characters,\n  /// creating a more permissive pattern that allows characters valid in either pattern.\n  static String _mergeInvalidCharsPatterns(String pattern1, String pattern2",
      "doc": ""
    },
    "joinPath": {
      "file": "lib/src/domain/core/entity_config.dart",
      "params": "List<String> segments",
      "doc": "Joins path segments using the configured path separator.\n  ///\n  /// This is a convenience method that ensures consistent path formatting.\n  /// It also sanitizes the result to ensure it conforms to all path constraints.\n  ///\n  /// Returns the joined path, sanitized according to configuration constraints."
    },
    "isValidLockDuration": {
      "file": "lib/src/domain/core/entity_config.dart",
      "params": "Duration lockDuration",
      "doc": "Validates that a lock duration is within the configured limits.\n  ///\n  /// Returns true if the duration is between minLockDuration and maxLockDuration."
    },
    "constrainLockDuration": {
      "file": "lib/src/domain/core/entity_config.dart",
      "params": "Duration lockDuration",
      "doc": "Adjusts a lock duration to fit within the configured limits.\n  ///\n  /// If the input duration is too short, returns minLockDuration.\n  /// If the input duration is too long, returns maxLockDuration.\n  /// Otherwise, returns the original duration."
    },
    "getNameFromPath": {
      "file": "lib/src/domain/core/entity_config.dart",
      "params": "String path",
      "doc": "Extracts the last segment (name) from a path.\n  ///\n  /// Returns the name component, or the full path if there are no separators."
    },
    "isParentPath": {
      "file": "lib/src/domain/core/entity_config.dart",
      "params": "String parentPath, String childPath",
      "doc": "Checks if one path is a parent of another path.\n  ///\n  /// Returns true if parentPath is a parent of childPath."
    },
    "isValidEntityName": {
      "file": "lib/src/domain/core/entity_config.dart",
      "params": "String name",
      "doc": "Validates an entity name based on configuration constraints.\n  ///\n  /// Returns true if the name:\n  /// - Is not empty\n  /// - Does not contain path separators\n  /// - Does not contain invalid characters\n  /// - Does not exceed maxPathSegment length"
    },
    "isCompatibleWith": {
      "file": "lib/src/domain/core/entity_config.dart",
      "params": "EntityConfig other",
      "doc": "Checks if this configuration is compatible with another configuration.\n  ///\n  /// A configuration is considered compatible when:\n  /// 1. Its path limits are equal to or greater than the other configuration\n  /// 2. It uses the same path separator character\n  /// 3. Its lock duration constraints can accommodate the other's default lock duration\n  ///\n  /// Returns true if this configuration is compatible with the other configuration."
    },
    "isVersionCompatible": {
      "file": "lib/src/domain/core/entity_config.dart",
      "params": "String otherVersion, [String? thisVersion]",
      "doc": "Checks if this configuration version is compatible with another version.\n  ///\n  /// [otherVersion] - Version string to check compatibility with (e.g., \"1.2.3\")\n  /// [thisVersion] - Optional version to check, defaults to this config's version\n  ///\n  /// Returns true if versions are compatible."
    },
    "incrementVersion": {
      "file": "lib/src/domain/core/entity_config.dart",
      "params": "String increment, [String? baseVersion]",
      "doc": "Creates a new version string following semantic versioning.\n  ///\n  /// [increment] - Which part to increment: \"major\", \"minor\", or \"patch\"\n  /// [baseVersion] - Optional base version, defaults to this config's version"
    },
    "withIncrementedVersion": {
      "file": "lib/src/domain/core/entity_config.dart",
      "params": "String increment",
      "doc": "Creates a new config with the version number incremented.\n  ///\n  /// This creates a new configuration with an updated version while\n  /// preserving all other settings.\n  ///\n  /// [increment] - Which part to increment: \"major\", \"minor\", or \"patch\"\n  ///\n  /// Returns a new EntityConfig with the updated version."
    },
    "DataManagerException": {
      "file": "lib/src/domain/core/exceptions.dart",
      "params": "{\n    required this.message,\n    this.details,\n    this.context,\n  });\n\n  @override\n  String toString(",
      "doc": "Base exception class for all data manager errors\nabstract class DataManagerException implements Exception {\n  final String message;\n  final String? details;\n  final Map<String, dynamic>? context;"
    }
  },
  "categories": {
    "entities": [
      "EntityCreationConfig",
      "EntityCloningConfig",
      "EntityCreationBuilder",
      "EntityCloningBuilder",
      "EntityFactory",
      "OwnerData",
      "SiteData",
      "EquipmentData",
      "VendorData",
      "PersonnelData",
      "EntityLimits",
      "EntityHierarchy",
      "EntitySecurity",
      "EntityClassification",
      "EntityVersioning",
      "BaseEntityModel",
      "EntityMetadata",
      "EntityConfigDefaults",
      "EntityConfig"
    ],
    "repositories": [],
    "services": [],
    "value_objects": [
      "EmailAddress",
      "PhoneNumber",
      "Address",
      "ContactInfo",
      "UserAction",
      "Measurement",
      "Range",
      "Progress",
      "TaskStatus",
      "TimeWindow",
      "Schedule",
      "EntityId",
      "EventId",
      "ReferenceNumber"
    ]
  }
}